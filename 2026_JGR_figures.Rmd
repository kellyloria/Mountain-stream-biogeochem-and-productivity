---
title: 'Analysis for Mountain stream ecosystem metabolism and nitrogen cycling responses to hydroclimatic volatility '
author: "Kelly Loria"
date: "`r Sys.Date()`"
output:
   html_document:
    theme: united
    highlight: tango
editor_options: 
  markdown: 
    wrap: 72
---

```{=html}
<style type="text/css">
body, td {font-size: 13px;}
code.r{font-size: 9px;}
pre {font-size: 11px}
</style>
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(warning = F, message = F)
knitr::opts_knit$set(root.dir = '/Users/kellyloria/Documents/Publications/')
def.chunk.hook  <- knitr::knit_hooks$get("chunk")
knitr::knit_hooks$set(chunk = function(x, options) {
  x <- def.chunk.hook(x, options)
  ifelse(options$size != "normalsize", paste0("\n \\", options$size,"\n\n", x, "\n\n \\normalsize"), x)
})

```

```{r, echo = F, message = F, include=FALSE}
### Packages
#setwd("/Users/kellyloria/Documents/Publications/2024_stream_metab_output/BWL_k600/")
lapply(c("plyr","dplyr","ggplot2","cowplot",
         "lubridate","tidyverse", "reshape2", "ggpubr", "ggpattern", "broom.mixed",
         "glmmTMB", "plotly", "MASS",
         "lme4", "lmerTest", "MuMIn", "PerformanceAnalytics", "car"), require, character.only=T)
```

### MS: Spatiotemporal variation in mountain stream metabolism and nitrogen cycling across contrasting flow regimes

```{r, warning=F, size = 'small', echo=FALSE, include=FALSE}
daoc_date<- Sys.Date()

lapply(c("plyr","dplyr","ggplot2","cowplot",
         "lubridate","tidyverse", "reshape2", "ggpubr", "ggpattern",
         "lme4", "lmerTest", "MuMIn", "PerformanceAnalytics", "car"), require, character.only=T)
detach("package:plyr", unload = TRUE)
site_colors <- c(
  "BWL" = "#054fb9",
  "BWU" = "#97b5c2",
  "GBL" = "#DD6E42",
  "GBU" = "#d9cb7c"
)

siteC_colors <- c(
  "BWL" = "#054fb9",
  "BWU" = "#054fb9",
  "GBL" = "#DD6E42",
  "GBU" = "#DD6E42"
)



catch_colors <- c(
  "BW" = "#054fb9",
  "GB" = "#DD6E42"
)

# Define fill patterns for water years
water_year_patterns <- c("wave","weave","stripe","circle", "stripe", "circle")


# Create a sequence of dates
date_seq <- seq(from = as.Date("2021-03-20"), to = as.Date("2024-10-10"), by = "day")

# Convert the sequence to a dataframe
date_df <- data.frame(date = date_seq)
date_df$site <- "BWL"
date_df$catch <- "BW"
date_df1 <- data.frame(date = date_seq)
date_df1$site <- "GBL"
date_df1$catch <- "GB"
date_df2 <- data.frame(date = date_seq)
date_df2$site <- "GBU"
date_df2$catch <- "GB"
date_df3 <- data.frame(date = date_seq)
date_df3$site <- "BWU"
date_df3$catch <- "BW"

date_datf <- rbind(date_df,date_df1,date_df2, date_df3)

### fxns:
## Fxn for water year:
water_year <- function(data) {
  # Ensure the `date` column exists
  if (!"date" %in% names(data)) {
    stop("The dataframe must contain a column named 'date'.")
  }
  
  # Convert the `date` column to Date format (if not already)
  data$date <- as.Date(data$date)
  
  # Add the water_year column
  data$water_year <- with(data, {
    year <- as.numeric(format(date, "%Y"))
    month <- as.numeric(format(date, "%m"))
    ifelse(month >= 10, year + 1, year)
  })
  
  return(data)
}
## Function to perform ANOVA and post-hoc test within each site
comparisons <- list(
  c("2021", "2022"),
  c("2021", "2023"),
  c("2022", "2023"),
  c("2023", "2024")
)
```

```{r, warning=F, size = 'small', echo=FALSE, include=F}
date_datf <- water_year(date_datf)



covariat_dat <- readRDS("/Users/kellyloria/Documents/Publications/CH1\ biogeochem\ linkages/data/CH1_covariate_dat_AFDM.rds") %>%
  dplyr::select("date", "Site","bulk.density","AFDM_mgg","AFDM_mgcm2", "Chla_ugL_Q", "Pheo_ugL_Q")
summary(covariat_dat)

covariat_dat <- date_datf %>%
  left_join(covariat_dat, by=c("date", "site"="Site"))

flow_df <- readRDS("/Users/kellyloria/Documents/Publications/CH1\ biogeochem\ linkages/data/CH1_flow_df.rds")

covariat_dat <- covariat_dat %>%
    left_join(flow_df, by=c("date", "site"))


bg_nuts <- 
  readRDS("/Users/kellyloria/Documents/LittoralMetabModeling/RawData/WaterChem/NS_chem_dat_nh4_24.rds") %>%
  filter(location=="stream") %>%
  mutate(NO3_mgL_dl = if_else(NO3_mgL_dl < 0.0015, 0.0015, NO3_mgL_dl))%>%
    mutate(NH4_mgL_dl=if_else(NH4_mgL_dl < 0.001, 0.001, NH4_mgL_dl))%>%
    mutate(PO4_ugL_dl=if_else(PO4_ugL_dl < 0.201, 0.201, PO4_ugL_dl)) %>%
  mutate(PO4_ugL_dl=if_else(DOC_mgL_dl < 0.25, 0.125, DOC_mgL_dl)) %>%
  group_by(site, shore, date, depth, location, substrate) %>%
  summarise(across(everything(), mean, na.rm = TRUE), .groups = "drop")


##### pivot wider 
bg_nuts_wide <- bg_nuts %>%
  dplyr::select(site, date, substrate, NO3_mgL_dl, NH4_mgL_dl, PO4_ugL_dl, DOC_mgL_dl, pH_infill) %>%
  group_by(site, date,substrate) %>% 
  summarise(across(c(NO3_mgL_dl, NH4_mgL_dl, PO4_ugL_dl, DOC_mgL_dl, pH_infill), mean, na.rm = TRUE), .groups = "drop") %>% 
  pivot_wider(names_from = substrate, values_from = c(NO3_mgL_dl, NH4_mgL_dl, PO4_ugL_dl, DOC_mgL_dl, pH_infill), names_sep = "_")

######


WQ_dat <- read.csv("/Users/kellyloria/Documents/LittoralMetabModeling/RawData/WaterChem/Stream_Lake_YSI_WaterQuality.csv")%>%
  mutate(date = as.Date(date, format="%m/%d/%y")) %>%
  dplyr::select("site", "date","pH") %>%
  dplyr:: group_by(site, date) %>%
  dplyr::summarise(pH=mean(pH, na.rm=T))

covariat_datq <- covariat_dat%>%
  left_join(bg_nuts_wide[ , c("site", "date", "NO3_mgL_dl_sw", "NO3_mgL_dl_pw", "NH4_mgL_dl_sw", 
                              "NH4_mgL_dl_pw", "PO4_ugL_dl_sw","PO4_ugL_dl_pw", "DOC_mgL_dl_sw",
                              "DOC_mgL_dl_pw", "pH_infill_sw",  "pH_infill_pw")], by=c("date", "site"))

covariat_datq <- covariat_datq%>%
  left_join(WQ_dat,  by=c("date", "site"))


## bring in SPC data 
### missing 2024 BW SPC
SPC_BWL <- readRDS("/Users/kellyloria/Documents/UNR/MSMmetab/23_CleanDat/24_BWL_SPCv2.rds") %>%
  filter(datetime>as.POSIXct("2021-04-29 24:00:00"))
SPC_BWL$site <- "BWL"
SPC_BWU <- readRDS("/Users/kellyloria/Documents/UNR/MSMmetab/23_CleanDat/24_BWU_SPCv2.rds")
SPC_BWU$site <- "BWU"
SPC_GBL <- readRDS("/Users/kellyloria/Documents/UNR/MSMmetab/23_CleanDat/24_GBL_SPCv2.rds")
SPC_GBL$site <- "GBL"
SPC_GBU <- readRDS("/Users/kellyloria/Documents/UNR/MSMmetab/23_CleanDat/24_GBU_SPCv2.rds")
SPC_GBU$site <- "GBU"

SPC_dat <- rbind(SPC_BWL, SPC_BWU, SPC_GBL, SPC_GBU)
SPC_dat <- SPC_dat %>%
  mutate(date =as.Date(datetime)) 

SPC_dat_day <- SPC_dat %>%
  dplyr::group_by(site, date) %>%
  dplyr::summarise(
    wt= mean(wtr, na.rm=T),
    wt_sd= sd(wtr, na.rm=T),
    SPC_m=mean(SPC, na.rm=T),
    SPC_sd=sd(SPC, na.rm=T))

SPC_datD <- SPC_dat_day %>%
  filter(wt_sd<4.1 & SPC_sd <35)

  
covariat_datq <- covariat_datq%>%
  left_join(SPC_datD, by=c("date", "site"))

### 
## Bring in morph data : 
morph_df <- read.csv("/Users/kellyloria/Documents/UNR/MSMmetab/stream_morphology_core.csv")%>%
  filter(quality =="trust") %>%
    mutate(datetime = as.POSIXct(datetime, format="%Y-%m-%dT%H:%M:%SZ"),
           date=as.Date(datetime)) %>%
  rename(site="Site")


Morph_dat_day <- morph_df%>%
  dplyr::group_by(site, date) %>%
  dplyr::summarise(
    v_m=mean(v_estimation, na.rm=T),
    w_m=mean(w, na.rm=T),
    depth_measure=mean(z, na.rm=T))


covariat_datq <- covariat_datq%>%
  left_join(Morph_dat_day, by=c("date", "site"))

#### DO ###
## BWL  
BWL_dat <- readRDS("/Users/kellyloria/Documents/Publications/2024_stream_metab_output/input_data/25_BWL_mod_dat.rds") %>%
  mutate(site="BWL")
summary(BWL_dat) 

## BWU 
BWU_dat <- readRDS("/Users/kellyloria/Documents/Publications/2024_stream_metab_output/BWU_k600/25_BWU_mod_dat.rds") %>%
  mutate(site="BWU")
summary(BWU_dat)

## GBL 
GBL_dat <- readRDS("/Users/kellyloria/Documents/Publications/2024_stream_metab_output/input_data/25_GBL_mod_dat.rds") %>%
  mutate(site="GBL")
summary(GBL_dat)

## GBU 
GBU_dat <- readRDS("/Users/kellyloria/Documents/Publications/2024_stream_metab_output/input_data/25_GBU_mod_dat.rds") %>%
  mutate(site="GBU")
summary(GBU_dat)


miniDOT_dat <- rbind(BWL_dat, BWU_dat, GBL_dat, GBU_dat)
miniDOT_dat_day <- miniDOT_dat%>%
  mutate(date =as.Date(solar.time))%>%
  dplyr::group_by(site, date) %>%
  dplyr::summarise(
    do.obs_m=mean(DO.obs, na.rm=T),
    do.obs_sd=sd(DO.obs, na.rm=T),
    wtr_m=mean(temp.water, na.rm=T),
    wtr_sd=sd(temp.water, na.rm=T))

covariat_datq <- covariat_datq%>%
  left_join(miniDOT_dat_day, by=c("date", "site"))

### N-uptake metrics
n_up <- read.csv("/Users/kellyloria/Documents/UNR/Ncycle/BTC_N_Table_2025_figure.csv")%>%
  mutate(date = as.Date(date, format="%m/%d/%y")) 

covariat_datq <- covariat_datq%>%
  left_join(n_up, by=c("date", "site"))

##================================
## Load metabolism model data
##================================
BWL_met_binned <- read_csv("/Users/kellyloria/Documents/Publications/2024_stream_metab_output/final_output_2025/BWL_Full_2025-02-06_daily.csv") %>%
  filter(GPP_daily_Rhat<1.05)%>%
  filter(GPP_97.5pct>0)%>%
  filter(ER_daily_Rhat<1.05) %>%
  filter(ER_2.5pct<0)%>%
  filter(K600_daily_Rhat<1.05) %>%
  mutate(
    GPP_mean = ifelse(GPP_mean < 0, 0.001, GPP_mean)) %>%
  filter(ER_mean < 0.01) %>%
  mutate(NEP_daily_mean = GPP_daily_mean + ER_daily_mean) %>%
  dplyr::select(date, GPP_mean, ER_mean, NEP_daily_mean, K600_daily_mean,
                GPP_2.5pct, GPP_97.5pct, 
                ER_2.5pct, ER_97.5pct,
                K600_daily_2.5pct, K600_daily_predlog_97.5pct,
                GPP_daily_Rhat, ER_daily_Rhat, K600_daily_Rhat) %>% 
  mutate(site="BWL",
         catch="BW")

summary(BWL_met_binned)

GBL_met_binned <- read_csv("/Users/kellyloria/Documents/Publications/2024_stream_metab_output/final_output_2025/GBL_Full_2025-02-02_daily.csv") %>%
  filter(GPP_daily_Rhat<1.05)%>%
  filter(GPP_97.5pct>0)%>%
  filter(ER_daily_Rhat<1.05) %>%
  filter(ER_2.5pct<0)%>%
  filter(K600_daily_Rhat<1.05) %>%
  mutate(
    GPP_mean = ifelse(GPP_mean < 0, 0.001, GPP_mean)) %>%
  filter(ER_mean < 0.01) %>%
  mutate(NEP_daily_mean = GPP_daily_mean + ER_daily_mean) %>%
  dplyr::select(date, GPP_mean, ER_mean, NEP_daily_mean, K600_daily_mean,
                GPP_2.5pct, GPP_97.5pct, 
                ER_2.5pct, ER_97.5pct,
                K600_daily_2.5pct, K600_daily_predlog_97.5pct,
                GPP_daily_Rhat, ER_daily_Rhat, K600_daily_Rhat) %>%
  mutate(site="GBL",
         catch="GB")


BWU_met_binned <- read_csv("/Users/kellyloria/Documents/Publications/2024_stream_metab_output/final_output_2025/BWU_Full_2025-02-04_daily.csv") %>%
  filter(GPP_daily_Rhat<1.05)%>%
  filter(GPP_97.5pct>0)%>%
  filter(ER_daily_Rhat<1.05) %>%
  filter(ER_2.5pct<0)%>%
  filter(K600_daily_Rhat<1.05) %>%
  mutate(
    GPP_mean = ifelse(GPP_mean < 0, 0.001, GPP_mean)) %>%
  filter(ER_mean < 0.01) %>%
  mutate(NEP_daily_mean = GPP_daily_mean + ER_daily_mean) %>%
  dplyr::select(date, GPP_mean, ER_mean, NEP_daily_mean, K600_daily_mean,
                GPP_2.5pct, GPP_97.5pct, 
                ER_2.5pct, ER_97.5pct,
                K600_daily_2.5pct, K600_daily_predlog_97.5pct,
                GPP_daily_Rhat, ER_daily_Rhat, K600_daily_Rhat) %>%
  mutate(site="BWU",
         catch="BW")

GBU_met_binned <- read_csv("/Users/kellyloria/Documents/Publications/2024_stream_metab_output/final_output_2025/GBU_Full_2025-02-03_daily.csv") %>%
  filter(GPP_daily_Rhat<1.05)%>%
  filter(GPP_97.5pct>0)%>%
  filter(ER_daily_Rhat<1.05) %>%
  filter(ER_2.5pct<0)%>%
  filter(K600_daily_Rhat<1.05) %>%
  mutate(
    GPP_mean = ifelse(GPP_mean < 0, 0.001, GPP_mean)) %>%
  filter(ER_mean < 0.01) %>%
  mutate(NEP_daily_mean = GPP_daily_mean + ER_daily_mean) %>%
  dplyr::select(date,GPP_mean, ER_mean, NEP_daily_mean, K600_daily_mean,
                GPP_2.5pct, GPP_97.5pct, 
                ER_2.5pct, ER_97.5pct,
                K600_daily_2.5pct, K600_daily_predlog_97.5pct,
                GPP_daily_Rhat, ER_daily_Rhat, K600_daily_Rhat) %>%
  mutate(site="GBU",
         catch="GB")

metab_dat <- rbind(BWL_met_binned, BWU_met_binned, GBL_met_binned, GBU_met_binned)

covariat_datq <- covariat_datq%>%
  left_join(metab_dat, by=c("date", "site", "catch"))


### read in streamlight data
## BWL  
BWL_SL_dat <- readRDS("/Users/kellyloria/Documents/Publications/CH1\ biogeochem\ linkages/data/CH1_StreamLightMod_BWL.rds")
summary(BWL_SL_dat) 

## BWU 
BWU_SL_dat <- readRDS("/Users/kellyloria/Documents/Publications/CH1\ biogeochem\ linkages/data/CH1_StreamLightMod_BWU.rds") 
summary(BWU_SL_dat)

## GBL 
GBL_SL_dat <- readRDS("/Users/kellyloria/Documents/Publications/CH1\ biogeochem\ linkages/data/CH1_StreamLightMod_GBL.rds") 
summary(GBL_SL_dat)

## GBU 
GBU_SL_dat <- readRDS("/Users/kellyloria/Documents/Publications/CH1\ biogeochem\ linkages/data/CH1_StreamLightMod_GBU.rds") 
summary(GBU_SL_dat)

light_mod_df <- rbind(BWL_SL_dat, BWU_SL_dat, GBL_SL_dat, GBU_SL_dat)

light_mod_df_day <- light_mod_df%>%
  mutate(date=as.Date(local_time)) %>%
  group_by(site, date)%>%
  summarise(across(everything(), mean, na.rm = TRUE), .groups = "drop") %>%
  dplyr::select(site, date, LAI, PAR_inc, PAR_bc, veg_shade, bank_shade, PAR_surface)


covariat_datq <- covariat_datq%>%
  left_join(light_mod_df_day, by=c("date", "site"))


```

```{r, warning=F, size = 'small', echo=F, include=F, fig.width=6, fig.height=4}
# temp summary save file 


light_mod_df_day1 <- water_year(light_mod_df_day)

light_data_HA1 <- light_mod_df_day1%>%
  mutate(yday=yday(date)) %>%
  filter(yday<253) %>% # 253
  mutate(catch = case_when(
    site== "BWL"~ "BW",
    site== "BWU"~ "BW",
    site== "GBL"~ "GB",
    site== "GBU"~ "GB",
    TRUE ~ NA_character_  )) %>%
  # mutate(cum_PAR_surface = cumsum(PAR_surface)) %>%
  dplyr::group_by(site) %>%
  summarise(mean_LAI = round(mean(LAI, na.rm=T),2),
            mean_veg_shade = round(mean(veg_shade, na.rm = T),2),
            mean_PAR_surface = round(mean(PAR_surface, na.rm = T),2),
            min_PAR_surface = min(PAR_surface, na.rm = T),
            max_PAR_surface = max(PAR_surface, na.rm = T),
            )


light_data_HA1


```

```{r, warning=F, size = 'small', echo=F, include=F, fig.width=6, fig.height=4}

covariat_datq$AFDM_ugcm2 <- (covariat_datq$AFDM_mgcm2 *1000)
#hist(covariat_datq$AFDM_ugcm2 )

covariat_datq$Biom_Chla <- (covariat_datq$AFDM_ugcm2)/(covariat_datq$Chla_ugL_Q)
#hist(covariat_datq$Biom_Chla)

summary(covariat_datq)

```

Pause to make a column for biomass to chla ratios And also make biomass
in in micro grams to more comparable to chl-a

```{r, warning=F, size = 'small', echo=F, include=F, fig.width=6, fig.height=4}

covariat_datq$AFDM_ugcm2 <- (covariat_datq$AFDM_mgcm2 *1000)
#hist(covariat_datq$AFDM_ugcm2 )

covariat_datq$Biom_Chla <- (covariat_datq$AFDM_ugcm2)/(covariat_datq$Chla_ugL_Q)
#hist(covariat_datq$Biom_Chla)
```

Additive columns for combined surface and pore water nutrient as tot\_
in ugL

```{r, warning=F, size = 'small', echo=T, include=F, fig.width=6, fig.height=4}

covariat_datq$tot_NO3_ugL <- c(covariat_datq$NO3_mgL_dl_pw + covariat_datq$NO3_mgL_dl_sw) *1000

covariat_datq$tot_NH4_ugL <- c(covariat_datq$NH4_mgL_dl_pw + covariat_datq$NH4_mgL_dl_sw) *1000

covariat_datq$tot_PO4_ugL <- c(covariat_datq$PO4_ugL_dl_pw + covariat_datq$PO4_ugL_dl_pw)

covariat_datq$tot_DOC_ugL <- c(covariat_datq$DOC_mgL_dl_pw + covariat_datq$DOC_mgL_dl_sw) *1000


summary(covariat_datq)

```

```{r, warning=F, size = 'small', echo=F, fig.width=10, fig.height=12}
# Separate out BW 
covariat_datq_BW <- covariat_datq%>%
  dplyr::filter(site=="BWL" | site=="BWU")

# Separate out GB 
covariat_datq_GB <- covariat_datq%>%
  dplyr::filter(site=="GBL" | site=="GBU")
```

##### Kernal density plots of GPP and ER

Colored by years

```{r, warning=F, size = 'small', echo=F, include=FALSE, fig.width=7, fig.height=8}
library(ggplot2)

BWL_KD_plot <- ggplot(covariat_datq%>%dplyr::filter(site=="BWL" & water_year<2025), aes(x = GPP_mean, y = ER_mean, color = as.factor(water_year))) +
  geom_density_2d(bins=10, size=1) + 
  geom_point(alpha=0.5, shape = 15)+
  geom_abline(slope = -1, intercept = 0, linetype = "dashed", color = "black") +  # 1:1 line
xlab(expression(GPP~(g~O[2]~m^-2~d^-1))) +
 ylab(expression(ER~(g~O[2]~m^-2~d^-1))) +
    scale_y_continuous(limits = c(-30, 0)) +  # Ensure zero is visible
      scale_x_continuous(position = "top", limits = c(0, 13)) +  # Set x limits & move axis
   scale_color_manual(values=c("#440154", "#3B528B", "#4bcc94", "#fad311")) +
#   scale_color_viridis_d(option = "viridis", name = "Water year") +
  theme_classic() +
          annotate("text", x = 7, y = -28, label = "Lower reach\nlarge creek",size =4, fontface = "bold", hjust = 0.5) 
# 

BWU_KD_plot <- ggplot(covariat_datq%>%dplyr::filter(site=="BWU" & water_year<2025), aes(x = GPP_mean, y = ER_mean, color = as.factor(water_year))) +
  geom_density_2d(bins=10, size=1) + 
  geom_point(alpha=0.5, shape=0)+
  geom_abline(slope = -1, intercept = 0, linetype = "dashed", color = "black") +  # 1:1 line
xlab(expression(GPP~(g~O[2]~m^-2~d^-1))) +
 ylab(expression(ER~(g~O[2]~m^-2~d^-1))) +
    scale_y_continuous(limits = c(-30, 0)) +  # Ensure zero is visible
      scale_x_continuous(position = "top", limits = c(0, 13)) +  # Set x limits & move axis
  scale_color_manual(values=c("#440154", "#3B528B", "#4bcc94", "#fad311")) +
#   scale_color_viridis_d(option = "viridis", name = "Water year") +
  theme_classic() +
            annotate("text", x = 7, y = -28, label = "Upper reach\nlarge creek", size = 4, fontface = "bold", hjust = 0.5) 



GBU_DF_clean <- covariat_datq%>%dplyr::filter(site=="GBU") %>%
filter(water_year<2025)%>%
  filter(!is.na(GPP_mean) & !is.na(ER_mean))%>%
  dplyr::select(date, water_year, GPP_mean, ER_mean)

# Compute 2D density
density_data <- with(GBU_DF_clean, kde2d(GPP_mean, ER_mean, n = 100))

# Convert density data to dataframe
density_df <- data.frame(
  expand.grid(x = density_data$x, y = density_data$y),
  z = as.vector(density_data$z)
)

# Plot with contour lines
GBU_KD_plot <- ggplot() +
  geom_point(data = GBU_DF_clean, aes(x = GPP_mean, y = ER_mean, color = as.factor(water_year)), alpha = 0.5, shape=2) +
    geom_contour(data = density_df, aes(x = x, y = y, z = z), color = "black", bins = 5, size=1) +
  geom_abline(slope = -1, intercept = 0, linetype = "dashed", color = "black") +  # 1:1 line
  scale_x_continuous(position = "top") +
    xlab(expression(GPP~(g~O[2]~m^-2~d^-1))) +
   # ylab(NULL) +
  ylab(expression(ER~(g~O[2]~m^-2~d^-1))) +
    scale_y_continuous(limits = c(-30, 0)) +  # Ensure zero is visible
    scale_x_continuous(position = "top", limits = c(0, 13)) +  # Set x limits & move axis
    scale_color_manual(values=c("#440154", "#3B528B", "#4bcc94","#fad311" )) +

 # scale_color_viridis_d(option = "viridis", name = "Water year") +
  theme_classic() +
        annotate("text", x = 7, y = -28, label = "Upper reach\nsmall creek", size = 4, fontface = "bold", hjust = 0.5) 

GBU_KD_plot


GBL_DF_clean <- covariat_datq%>%dplyr::filter(site=="GBL") %>%
  filter(!is.na(GPP_mean) & !is.na(ER_mean))%>%
  dplyr::select(date, water_year, GPP_mean, ER_mean)


# Plot with contour lines
GBL_KD_plot <- ggplot() +
#  geom_contour(data = density_df, aes(x = x, y = y, z = z), color = "black", bins = 10) +
  geom_point(data = GBL_DF_clean%>%filter(water_year<2025), aes(x = GPP_mean, y = ER_mean, color = as.factor(water_year)), alpha = 0.5, shape=17) +
  geom_abline(slope = -1, intercept = 0, linetype = "dashed", color = "black") +  # 1:1 line
  scale_x_continuous(position = "top") +
    xlab(expression(GPP~(g~O[2]~m^-2~d^-1))) +
  # xlab(NULL) +
  ylab(expression(ER~(g~O[2]~m^-2~d^-1))) +
  scale_y_continuous(limits = c(-30, 0)) +  # Ensure zero is visible
      scale_x_continuous(position = "top", limits = c(0, 13)) +  # Set x limits & move axis
 #scale_color_viridis_d(option = "viridis",  name = "Water year") +
    scale_color_manual(values=c("#440154", "#3B528B", "#4bcc94","#fad311")) +
  theme_classic() +
      annotate("text", x = 7, y = -28, label = "Lower reach\nsmall creek", size = 4, fontface = "bold", hjust = 0.5) 


```

```{r, warning=F, size = 'small', echo=F, include=F, fig.width=4, fig.height=10}
# Modify each plot to rename legend title & adjust legend formatting
BWL_KD_plot <- BWL_KD_plot + 
  guides(color = guide_legend(title = "Water year", nrow = 2))

BWU_KD_plot <- BWU_KD_plot + 
  guides(color = guide_legend(title = "Water year", nrow = 2))

GBL_KD_plot <- GBL_KD_plot + 
  guides(color = guide_legend(title = "Water year", nrow = 2))

GBU_KD_plot <- GBU_KD_plot + 
  guides(color = guide_legend(title = "Water year", nrow = 2))
```

### Modified figure 2

```{r, warning=F, size = 'small', echo=F, fig.width=9, fig.height=7}
# Arrange plots with shared legend at the bottom
KD_coeff_grid <- ggarrange(
  BWL_KD_plot,
  BWU_KD_plot,
  GBL_KD_plot,
  GBU_KD_plot,
  labels = c("a", "b", "c", "d"),
  ncol = 2, nrow = 2,
  common.legend = TRUE, 
  legend = "bottom"
)

KD_coeff_grid
```

```{r, warning=F, size = 'small', echo=F, include=FALSE}
# ggsave("/Users/kellyloria/Documents/Publications/CH1\ biogeochem\ linkages/Figs/Fig3_KD_CH1_grid_rev.png", plot = KD_coeff_grid, width = 6.25, height = 6.25, units = "in")

```




### **Figure 2**
Setting: Showing the delayed onset of baseflow in wetter years.
Color as water year. 

DOY - April 1 = 91
DOY - May 1 = 121
DOY -June 1 = 152
DOY - Sept 1 = 244
DOY - Oct 1 = 274

```{r, warning=F, size = 'small', echo=F, include=FALSE}

names(covariat_datq)

covariat_datq<-covariat_datq%>%
  mutate(yday=yday(date))


overall_pf<- covariat_datq %>%
    filter(yday >= 92, yday <= 153) %>%
  group_by(site, water_year) %>%
  summarise(
    max_pf = max(Q_m, na.rm = TRUE),
    min_pf = min(Q_m, na.rm = TRUE),
    max_pf_yday = yday[which.max(Q_m)],
    min_pf_yday = yday[which.min(Q_m)],
    mean_pf = mean(Q_m, na.rm = TRUE),
    mean_pf_yday = yday[which.min(abs(Q_m - mean_pf))]) %>%
  ungroup()


overall_bf<- covariat_datq %>%
    filter(yday >= 170, yday <= 274) %>%
  group_by(site) %>%
  summarise(
    max_q = max(Q_m, na.rm = TRUE),
    min_q = min(Q_m, na.rm = TRUE),
    max_q_yday = yday[which.max(Q_m)],
    min_q_yday = yday[which.min(Q_m)],
    mean_q = mean(Q_m, na.rm = TRUE),
    mean_q_yday = yday[which.min(abs(Q_m - mean_q))]) %>%
  ungroup()


overall_bf_df <- covariat_datq %>%
  left_join(overall_bf, by = c("site"))


steepest_slopes <- overall_bf_df %>%
    filter(yday >= 153, yday <= 274) %>%
  #  arrange(site, water_year, yday) %>%
  mutate(
    mean_q = case_when(
      site == "GBL" & water_year == 2023 ~ mean_q + 0.031,  # Adjust ave_q for GBL in 2021
      TRUE ~ mean_q)) %>%
  mutate(
    mean_q = case_when(
      site == "GBL" & water_year == 2024 ~ mean_q + 0.01,  # Adjust ave_q for GBL in 2021
      TRUE ~ mean_q)) %>%
    mutate(
    Q_m = case_when(
      site == "GBL" & water_year == 2021 ~ Q_m + 0.001,  # Adjust ave_q for GBL in 2021
      TRUE ~ Q_m)) %>%
  group_by(site, water_year) %>%
  summarise(
    ave_q = mean(mean_q, na.rm = TRUE),
    max_q = max(Q_m, na.rm = TRUE),
    min_q = min(Q_m, na.rm = TRUE),
    max_q_yday = yday[which.max(Q_m)],
    min_q_yday = yday[which.min(Q_m)],
    mean_q_yday = yday[which.min(abs(Q_m - mean_q))]
  ) %>%
  ungroup() 

```

```{r, warning=F, size = 'small', echo=F, include=F}
# Merge covariat_datq with steepest_slopes to get mean_q_yday
Baseflowplots <- covariat_datq %>%
  dplyr::select(date, site, catch, water_year, Q_m, yday) %>%
  left_join(steepest_slopes %>% 
              dplyr::select(site, water_year, mean_q_yday, ave_q), by = c("site", "water_year","yday"= "mean_q_yday")) %>%
  left_join(overall_pf %>% 
              dplyr::select(site, water_year, max_pf, max_pf_yday), by = c("site", "water_year", "yday"= "max_pf_yday"))  %>%filter(site=="BWL" | site=="GBL")


Baseflowplot1 <- Baseflowplots%>%
  mutate(
    ave_q = case_when(
      site == "GBL" & water_year == 2021 ~ ave_q - 0.006,  # Adjust ave_q for GBL in 2021
      TRUE ~ ave_q))


Baseflowplot <- ggplot(Baseflowplot1 %>% 
                         filter(water_year < 2025), 
                       aes(x = yday, y = Q_m, color = as.factor(water_year))) +
  geom_line() +  
  scale_color_viridis_d(name = "Year") +  
  xlim(91, 234) + 
  facet_wrap(.~site, scales = "free") + 
  theme_classic() + 
  ylab(expression(Streamflow~(m^3~s^-1))) +
  xlab("Day of year") +

  # Vertical lines at ave_q day
  geom_vline(data = Baseflowplot1 %>% filter(water_year < 2025),
             aes(xintercept = yday[ave_q == ave_q], color = as.factor(water_year)),
             linetype = "dashed", size = 0.5, alpha = 0.9) +

  # Points for max_pf and ave_q
  geom_point(aes(x = yday, y = ave_q, color = as.factor(water_year)), 
             shape = 19, size = 1.5, alpha = 0.9)

BF_sum <- Baseflowplot1%>%
  filter(!is.na(Baseflowplot1$ave_q))

BF_sum

```


Read in data from SNOTEL to get SWE timesieries 

```{r eval=TRUE, echo = F, error=FALSE, warning=FALSE, message=FALSE}
# read in the sites data for all SNOTEL sites
target_snow_data <- snotelr::snotel_download(network = "sntl",
                                             site_id = c(848, 615), 
                                             metric = TRUE, internal = TRUE)
target_snow_data$date<- as.Date(target_snow_data$date)

# transform for water year:
target_snow_dat<- water_year(target_snow_data)

#Trim for columns 
target_snow_df <- target_snow_dat %>%
  filter(water_year>2019) %>%
  filter(date < as.Date("2024-10-10")) %>%
  mutate(site = case_when(
    site_id == 615 ~ "GBL",
    site_id %in% c(848) ~ "BWL")) %>%
  dplyr::select(site_id,
                site,
                date,
                water_year,
                precipitation,
                snow_water_equivalent,
                precipitation_cumulative) %>%
  mutate(SWE = 0.001 *snow_water_equivalent)

summary(target_snow_df)

```


```{r, warning=F, size = 'small', echo=F, fig.width=9, fig.height=4.25}

library(dplyr)
library(ggplot2)

draw_order <- c(2023, 2024, 2022, 2021)

Baseflowplot_BWL <- local({

  df_BWL <- Baseflowplot_df %>%
    filter(water_year < 2025, site == "BWL") %>%
    mutate(
      label = "Large creek (BW)",
      year_level = factor(water_year, levels = draw_order)
    ) %>%
    arrange(factor(water_year, levels = draw_order))

  df <- df_BWL %>%
    filter(between(yday, 91, 234))

  # Use only the plotted window to get sensible scaling
  Q_top <- max(df$Q_m, na.rm = TRUE) * 1.35
  SWE_max <- max(df$SWE, na.rm = TRUE)
  k <- Q_top / SWE_max

  df <- df %>%
    mutate(
      SWE_ymin = Q_top - k * SWE * 0.5,
      SWE_ymax = Q_top
    )

  ggplot(df, aes(x = yday)) +

    geom_rect(
      aes(
        xmin = yday - 0.5, xmax = yday + 0.5,
        ymin = SWE_ymin, ymax = SWE_ymax,
        fill = year_level
      ),
      alpha = 0.75,
      inherit.aes = FALSE
    ) +

    geom_line(aes(y = Q_m, color = year_level), linewidth = 0.9) +

    geom_vline(
      data = df_BWL,
      aes(xintercept = yday[ave_q == ave_q], color = year_level),
      linetype = "dashed", linewidth = 0.5, alpha = 0.9
    ) +

    facet_grid(label ~ ., scales = "free") +

    scale_color_manual(
      values = c("2021" = "#440154", "2022" = "#3B528B", "2023" = "#4bcc94", "2024" = "#fad311"),
      name = "Water year"
    ) +
    scale_fill_manual(
      values = c("2021" = "#440154", "2022" = "#3B528B", "2023" = "#4bcc94", "2024" = "#fad311"),
      name = "Water year"
    ) +

    scale_y_continuous(
      limits = c(0, Q_top),
      name = expression(Streamflow~(m^3~s^-1)),
      sec.axis = sec_axis(
        trans = ~ (Q_top - .) / k,
        name  = "Snow water equivalent (m)"
      )
    ) +

    xlab("Day of year") +
    theme_classic() +
    theme(legend.position = "bottom") +

    geom_text(aes(x = 187, y = 11.5, label = "51 days"),
              color = "#440154", size = 4, hjust = 1, vjust = 1, fontface = "bold") +
    geom_text(aes(x = 207, y = 10.25, label = "30 days"),
              color = "#3B528B", size = 4, hjust = 1, vjust = 1, fontface = "bold") +
    geom_text(aes(x = 210, y = 8.5, label = "27 days"),
              color = "#fad311", size = 4, hjust = 1, vjust = 1, fontface = "bold")
})

Baseflowplot_BWL

```


```{r, warning=F, size = 'small', echo=F, fig.width=9, fig.height=4.25}


library(dplyr)
library(ggplot2)

draw_order <- c(2023, 2024, 2022, 2021)

Baseflowplot_GBL <- local({

  df_GBL <- Baseflowplot_df %>%
    filter(water_year < 2025, site == "GBL") %>%
    mutate(
      label = "Small creek (GB)",
      year_level = factor(water_year, levels = draw_order)
    ) %>%
    arrange(factor(water_year, levels = draw_order))

  df <- df_GBL %>%
    filter(between(yday, 91, 234))

  # Use only the plotted window to get sensible scaling
  Q_top <- max(df$Q_m, na.rm = TRUE) * 1.35
  SWE_max <- max(df$SWE, na.rm = TRUE)
  k <- Q_top / SWE_max

  df <- df %>%
    mutate(
      SWE_ymin = Q_top - k * SWE * 0.5,
      SWE_ymax = Q_top
    )

  ggplot(df, aes(x = yday)) +

    geom_rect(
      aes(
        xmin = yday - 0.5, xmax = yday + 0.5,
        ymin = SWE_ymin, ymax = SWE_ymax,
        fill = year_level
      ),
      alpha = 0.75,
      inherit.aes = FALSE
    ) +

    geom_line(aes(y = Q_m, color = year_level), linewidth = 0.9) +

    geom_vline(
      data = df_GBL,
      aes(xintercept = yday[ave_q == ave_q], color = year_level),
      linetype = "dashed", linewidth = 0.5, alpha = 0.9
    ) +

    facet_grid(label ~ ., scales = "free") +

    scale_color_manual(
      values = c("2021" = "#440154", "2022" = "#3B528B", "2023" = "#4bcc94", "2024" = "#fad311"),
      name = "Water year"
    ) +
    scale_fill_manual(
      values = c("2021" = "#440154", "2022" = "#3B528B", "2023" = "#4bcc94", "2024" = "#fad311"),
      name = "Water year"
    ) +

    scale_y_continuous(
      limits = c(0, Q_top),
      name = expression(Streamflow~(m^3~s^-1)),
      sec.axis = sec_axis(
        trans = ~ (Q_top - .) / k,
        name  = "Snow water equivalent (m)"
      )
    ) +

    xlab("Day of year") +
    theme_classic() +
    theme(legend.position = "bottom") +
  geom_text(
            aes(x = 179, y = 0.88, label = "42 days"),  # Adjusted to max Q_m and max yday for top-right corner
            color = "#440154", size = 4, hjust = 1, vjust = 1, fontface = "bold") +
  geom_text(
            aes(x = 187, y = 0.78, label = "38 days"),  # Adjust the position and text as needed
            color = "#3B528B", size = 4, hjust = 1, vjust = 1, fontface = "bold") +
  geom_text(
            aes(x = 198, y = 0.65, label = "29 days"),  # Adjust the position and text as needed
            color = "#fad311", size = 4, hjust = 1, vjust = 1, fontface = "bold")
})

Baseflowplot_GBL


```


```{r, warning=F, size = 'small', echo=F, fig.width=9, fig.height=6.25}

baseflow_grid <- ggarrange(
  Baseflowplot_BWL,
  Baseflowplot_GBL,
  labels = c("a", "b"),
  ncol = 1, nrow = 2,
  common.legend = TRUE, 
  legend = "bottom"
)


baseflow_grid
```





```{r, warning=F, size = 'small', echo=F, include=FALSE}
# ggsave("/Users/kellyloria/Documents/Publications/CH1\ biogeochem\ linkages/Figs/Fig2_baseflow_combined.png", plot = baseflow_grid, width =5.5, height = 6.5, units = "in")

```



#### Calculate nitrogen demand:

```{r, warning=F, size = 'small', echo=T, include=T,fig.width=6, fig.height=4}
# Constants
ra <- 0.5  # Autotrophic respiration coefficient (Hall & Tank 2003)
C_Nauto <- 16  # Autotrophic C:N ratio (Stelzer & Lamberti 2001)
C_Nhetero <- 20  # Heterotrophic C:N ratio (Hall & Tank 2003)
HGE <- 0.05  # Heterotrophic Growth Efficiency (Hall & Tank 2003)

# Calculate components of nitrogen demand
covariat_ndemand <- covariat_datq %>%
  group_by(site) %>% 
  mutate(
    # Autotrophic respiration (raGPP)
    raGPP = GPP_mean * ra,
    # Autotrophic assimilation of N
    Auto_N_assim = GPP_mean / C_Nauto,
    # Heterotrophic respiration (Rh)
    Rh = ER_mean - raGPP,
    # Heterotrophic assimilation of N
    Hetero_N_assim = (Rh * HGE) / C_Nhetero,
    # Total nitrogen demand
    Ndemand = Auto_N_assim + Hetero_N_assim, # unit should be g N m-2 d-1
    Ndemand = if_else(Ndemand < 0, 0.0001, Ndemand)) %>%
  dplyr::select(site, date, Ndemand)
```


```{r, warning=F, size = 'small', echo=F, include=F, fig.width=6, fig.height=4}

### Quality check on supply calculations:
# (1) How many data points do we have for velocity (v) and width (w)?

morph_counts <- covariat_datq %>%
  group_by(site) %>%
  summarise(
    w_m_count = sum(!is.na(w_m)), 
    v_m_count = sum(!is.na(v_m))
  )

morph_counts
```


```{r, warning=F, size = 'small', echo=F, include=F,fig.width=6, fig.height=4}
##### better way to infill width and velocites to get at reach length:
# na.approx, and using Q as "Variables to be used for interpolation as in"


covariat_datqI <- covariat_datq %>%
  group_by(site) %>%
  arrange(date) %>%
  mutate(
    # Fit a linear model for w_m ~ Q_m using non-missing values
    w_m_apr = ifelse(is.na(w_m), predict(lm(w_m ~ depth_m, data = cur_data(), na.action = na.omit), newdata = cur_data()), w_m),
    v_m_apr = ifelse(is.na(v_m), predict(lm(v_m ~ Q_m, data = cur_data(), na.action = na.omit), newdata = cur_data()), v_m)
  ) %>%
  ungroup()

covariat_datqI <- covariat_datqI %>%
  group_by(site) %>%
  arrange(date) %>%  # Ensure chronological order
   mutate( ## 17 NAs
    w_m_apr = ifelse(is.na(w_m_apr),
                  rollapplyr(w_m_apr, width = 15, FUN = function(x) mean(x, na.rm = TRUE), fill = NA, partial = TRUE),
                  w_m_apr),
    v_m_apr = ifelse(is.na(v_m_apr),
                  rollapplyr(v_m_apr, width = 15, FUN = function(x) mean(x, na.rm = TRUE), fill = NA, partial = TRUE),
                  v_m_apr))
```

```{r, warning=F, size = 'small', echo=F,include=F, fig.width=9, fig.height=10}

TS_plot_w <- ggplot(covariat_datqI, aes(x = date, y = w_m_apr, color=site, shape =site)) +
  geom_point(size = 2, alpha = 0.5, position = position_dodge(width = 0.3)) +
  geom_point(size = 2, alpha = 0.7) +
  geom_point(aes(x = date, y = w_m), color="black") +
  scale_color_manual(values = siteC_colors) +
  scale_shape_manual(values = c(15, 0, 17, 2)) + theme_classic() +
  facet_grid(site~.)

TS_plot_v <- ggplot(covariat_datqI, aes(x = date, y = v_m_apr, color=site, shape =site)) +
  geom_point(size = 3, alpha = 0.95, position = position_dodge(width = 0.3)) +
  geom_point(size = 2, alpha = 0.7) +
    geom_point(aes(x = date, y = v_m), color="black") +
  scale_shape_manual(values = c(15, 0, 17, 2)) +
    scale_color_manual(values = siteC_colors) +
  theme_classic() +facet_grid(site~.)

n_s_grid <- ggarrange(
  TS_plot_w,
  TS_plot_v,
  labels = c("a", "b"),
  ncol = 1, nrow = 2,
  label.x = 0.95,  # Move label to the right
  label.y = 1,     # Keep label at the top
  hjust = 1,       # Right-align the label
  vjust = 1        # Top-align the label
)

n_s_grid

# Where the black points are the survey measures of width or velocity.


```





#### Calculate nitrogen supply:

```{r, warning=F, size = 'small', echo=T, include=T,fig.width=6, fig.height=4}
covariat_nsupply <- covariat_datqI %>%
  left_join(nitrogen_data, by=c("date", "site")) %>%
  dplyr::select(site, catch, date, water_year, reach_length,
                v_m_apr,w_m_apr, Q_m, K600_daily_mean,
                NO3_mgL_dl_sw, NH4_mgL_dl_sw, PO4_ugL_dl_sw, NO3_mgL_i, NH4_mgL_i) %>%
  mutate(
    K600_daily_mean = case_when(
      is.na(K600_daily_mean) & site == "BWL" ~ 22, 
      is.na(K600_daily_mean) & site == "BWU" ~ 16,
      is.na(K600_daily_mean) & site == "GBU" ~ 32,
      is.na(K600_daily_mean) & site == "GBL" ~ 25,
      TRUE ~ K600_daily_mean)) %>%
  mutate(Q_Ls = Q_m * 1000, # flow from csm to Ls
  # calculate reach length in m
  reachL = c((v_m_apr*w_m_apr*8640)/K600_daily_mean), # seconds to days
   # Calculate no3 supply 
  NO3_supply = c(((86400*Q_Ls*(NO3_mgL_dl_sw/1000))/(w_m_apr*reachL))),
  NO3_supply_new = c(((86400*Q_Ls*(NO3_mgL_i/1000))/(w_m_apr*reachL))),

   # Calculate nh3 supply 
  NH4_supply = c(((86400*Q_Ls*(NH4_mgL_dl_sw/1000))/(w_m_apr*reachL))), ## unit should be g N m-2 d-1
 NH4_supply_new = c(((86400*Q_Ls*(NH4_mgL_i/1000))/(w_m_apr*reachL))),
  PO4_supply = c(((86400*Q_Ls*(PO4_ugL_dl_sw/1e-6))/(w_m_apr*reachL))) ## unit should be g N m-2 d-1
   )  %>%
  dplyr::select(site, date, reachL, reach_length, Q_Ls, NO3_supply, 
                NO3_supply_new, NH4_supply, PO4_supply, NH4_supply_new, NO3_mgL_i, NH4_mgL_i, PO4_ugL_dl_sw)

```



```{r, warning=F, size = 'small', echo=F, include=F, fig.width=6, fig.height=4}
ndyn <- covariat_datq %>%
  left_join(covariat_nsupply, by=c("site", "date"))%>%
  left_join(covariat_ndemand, by=c ("site", "date")) 

summary(ndyn)

```


### **Figure 2**
Setting: Showing the delayed onset of baseflow in wetter years.
Color as water year. 

DOY - April 1 = 91
DOY - May 1 = 121
DOY -June 1 = 152
DOY - Sept 1 = 244
DOY - Oct 1 = 274

```{r, warning=F, size = 'small', echo=F, include=FALSE}

names(covariat_datq)

covariat_datq<-covariat_datq%>%
  mutate(yday=yday(date))


overall_pf<- covariat_datq %>%
    filter(yday >= 92, yday <= 153) %>%
  group_by(site, water_year) %>%
  summarise(
    max_pf = max(Q_m, na.rm = TRUE),
    min_pf = min(Q_m, na.rm = TRUE),
    max_pf_yday = yday[which.max(Q_m)],
    min_pf_yday = yday[which.min(Q_m)],
    mean_pf = mean(Q_m, na.rm = TRUE),
    mean_pf_yday = yday[which.min(abs(Q_m - mean_pf))]) %>%
  ungroup()


overall_bf<- covariat_datq %>%
    filter(yday >= 170, yday <= 274) %>%
  group_by(site) %>%
  summarise(
    max_q = max(Q_m, na.rm = TRUE),
    min_q = min(Q_m, na.rm = TRUE),
    max_q_yday = yday[which.max(Q_m)],
    min_q_yday = yday[which.min(Q_m)],
    mean_q = mean(Q_m, na.rm = TRUE),
    mean_q_yday = yday[which.min(abs(Q_m - mean_q))]) %>%
  ungroup()


overall_bf_df <- covariat_datq %>%
  left_join(overall_bf, by = c("site"))


steepest_slopes <- overall_bf_df %>%
    filter(yday >= 153, yday <= 274) %>%
  #  arrange(site, water_year, yday) %>%
  mutate(
    mean_q = case_when(
      site == "GBL" & water_year == 2023 ~ mean_q + 0.031,  # Adjust ave_q for GBL in 2021
      TRUE ~ mean_q)) %>%
  mutate(
    mean_q = case_when(
      site == "GBL" & water_year == 2024 ~ mean_q + 0.01,  # Adjust ave_q for GBL in 2021
      TRUE ~ mean_q)) %>%
    mutate(
    Q_m = case_when(
      site == "GBL" & water_year == 2021 ~ Q_m + 0.001,  # Adjust ave_q for GBL in 2021
      TRUE ~ Q_m)) %>%
  group_by(site, water_year) %>%
  summarise(
    ave_q = mean(mean_q, na.rm = TRUE),
    max_q = max(Q_m, na.rm = TRUE),
    min_q = min(Q_m, na.rm = TRUE),
    max_q_yday = yday[which.max(Q_m)],
    min_q_yday = yday[which.min(Q_m)],
    mean_q_yday = yday[which.min(abs(Q_m - mean_q))]
   # max_slope = max(slope, na.rm = TRUE),
  #  max_slope_yday = yday[which(slope == max(slope, na.rm = TRUE))[1]],
  #  min_slope = min(slope, na.rm = TRUE),
  #  min_slope_yday = yday[which(slope == min(slope, na.rm = TRUE))[1]]
  ) %>%
  ungroup() 

```




##### Plots of Ratios of NH4+- N supply to demand, ratios NO3-- N supply to demand

Remaid figure 4: Now with chemistry data aligned to data data frame so
that there are no sample NAs for NO3 and Nh4 when the metabolism model
failed to estimate that parameter on the same day as the chemistry
sample.

Color is now also by water year 2021-2024, and shape is reach location.

```{r, warning=F, size = 'small', echo=F, include=F}
covariat_NS_ND <- ndyn %>%
  mutate(jday = yday(date)) %>%
  dplyr::select(date, jday, Q_m, w_m, site, catch, water_year, 
                Ndemand, NO3_supply_new, NO3_supply, NH4_supply, NH4_supply_new,
                NH4_mgL_i, NO3_mgL_i) %>%
  mutate(
    NO3_SupDem = NO3_supply / Ndemand,
    NH4_SupDem = NH4_supply / Ndemand,
    N_SupDem = (NH4_supply + NO3_supply) / Ndemand
  ) %>%
  distinct(date, site, .keep_all = TRUE)  %>%
    mutate(WY_lab = case_when(
    water_year %in% c(2021, 2022) ~ "dry",
    water_year %in% c(2023) ~ "wet",
    water_year %in% c(2024) ~ "normal",
    TRUE ~ NA_character_  
  )) %>%
    group_by(site, date, catch) %>%
    summarise(across(everything(), mean, na.rm = TRUE), .groups = "drop")

covariat_NS_ND1 <- covariat_NS_ND%>%
  left_join(Baseflowplot1, by=c("site", "date", "catch",
                                "water_year", "Q_m"))
  


NO3_supp_plots <- ggplot(covariat_NS_ND1%>%filter(water_year<2025 & jday<274), aes(y = (NO3_supply_new), x = jday, color = as.factor(water_year), shape=site)) +
  geom_point(size = 2, alpha = 0.85, position = position_dodge(width = 0.3)) +
  geom_point( aes(y = log(NH4_supply_new+1), x = jday, color = as.factor(water_year), shape=site), 
                size = 2, alpha = 0.85, position = position_dodge(width = 0.3)) +
    scale_color_viridis_d(option = "viridis", name = "Water year") +  # Use _c for continuous data
  scale_x_continuous(
  limits = c(15, 285),
  breaks = seq(15, 285, by = 30)  
)+
  ylim(0,1.50) +
   xlab(NULL) +
       scale_color_manual(values=c("#440154", "#3B528B", "#4bcc94", "#fad311")) +
      scale_fill_manual(values=c("#440154", "#3B528B", "#4bcc94", "#fad311")) +
    scale_y_continuous(trans = "log", breaks = scales::log_breaks(base = 10)) +
  geom_smooth(aes(group = as.factor(water_year), fill = as.factor(water_year)), 
            se = TRUE, linewidth = 1, method = "gam", formula = y ~ s(x, k = 10), alpha = 0.1)+
     ylab(expression(Supply~(g~N~m^-2~d^-1))) +
  theme_classic() +
  scale_shape_manual(values = c(15,0,17,2)) +
    theme(legend.position = "none") +
    geom_vline(data = covariat_NS_ND1 %>% filter(water_year < 2025),
             aes(xintercept = jday[ave_q == ave_q], color = as.factor(water_year)),
             linetype = "dashed", size = 0.5, alpha = 0.9) +
   facet_grid(catch~.) 

# Remove legend

# Define threshold for high NO3 demand (above 3rd quartile)
high_Ndemand_threshold <- 0.075

N_demand_plot1 <- ggplot(covariat_NS_ND1%>%filter(water_year<2025), aes(y = (Ndemand), x = jday, color = as.factor(water_year), shape = site)) +
  geom_point(size = 2, alpha = 0.85, position = position_dodge(width = 0.8)) +
 # scale_color_viridis_d(option = "viridis", name = "Water year") +  # Use _c for continuous data
      scale_color_manual(values=c("#440154", "#3B528B", "#4bcc94",  "#fad311")) +
      scale_fill_manual(values=c("#440154", "#3B528B", "#4bcc94",  "#fad311")) +
  #  scale_fill_viridis_d(option = "viridis", name = "Water year") +  # Use _c for continuous data
  xlab("Day of year") + 
    geom_smooth(aes(group = as.factor(water_year), fill = as.factor(water_year)), 
            se = TRUE, linewidth = 1, method = "gam", formula = y ~ s(x, k = 10), alpha = 0.1)+
    scale_x_continuous(
  limits = c(15, 285),
  breaks = seq(15, 285, by = 30)  
)+
    scale_y_continuous(trans = "log", breaks = scales::log_breaks(base = 10),
                         labels = scales::label_number()) +
 # geom_hline(yintercept = high_Ndemand_threshold, linetype = "dashed", color = "grey25") +
  scale_shape_manual(values = c(15, 0, 17, 2)) +
  ylab(expression(Demand~(g~N~m^-2~d^-1))) +
  theme_classic() +
  theme(legend.position = "none")  +
    facet_grid(catch~.) +
    geom_vline(data = covariat_NS_ND1 %>% filter(water_year < 2025),
             aes(xintercept = yday[ave_q == ave_q], color = as.factor(water_year)),
             linetype = "dashed", size = 0.5, alpha = 0.9) 


N_demand_plot1

```

### **Figure 5**


```{r, warning=F, size = 'small', echo=F,include=F, fig.width=12, fig.height=6}

n_s_grid <- ggarrange(
  NO3_supp_plots,
  N_demand_plot1,
  labels = c("b", "c"),
    align = c("v"),
  ncol = 1, nrow = 2,
  label.x = 0.91,  # Move label to the right
  label.y = 1,     # Keep label at the top
  hjust = 1,       # Right-align the label
  vjust = 1        # Top-align the label
)



n_s_grid


```

```{r, warning=F, size = 'small', echo=F, include=F, fig.width=9, fig.height=4}
# ggsave("/Users/kellyloria/Documents/Publications/CH1\ biogeochem\ linkages/Figs/Nsupply_grid_CH1_SFS_ppt_21.png", plot = n_s_grid, width = 8.5, height = 7.75, units = "in")

```




##### Plots of Ratios of NH4+- N supply to demand, ratios NO3-- N supply to demand

Remaid figure 4: Now with chemistry data aligned to data data frame so
that there are no sample NAs for NO3 and Nh4 when the metabolism model
failed to estimate that parameter on the same day as the chemistry
sample.

Color is now also by water year 2021-2024, and shape is reach location.

```{r, warning=F, size = 'small', echo=F, include=F}
covariat_NS_ND <- ndyn %>%
  mutate(jday = yday(date)) %>%
  dplyr::select(date, jday, Q_m, w_m, site, catch, water_year, 
                Ndemand, NO3_supply_new, NO3_supply, NH4_supply, NH4_supply_new,
                NH4_mgL_i, NO3_mgL_i) %>%
  mutate(
    NO3_SupDem = NO3_supply / Ndemand,
    NH4_SupDem = NH4_supply / Ndemand,
    N_SupDem = (NH4_supply + NO3_supply) / Ndemand
  ) %>%
  distinct(date, site, .keep_all = TRUE)  %>%
    mutate(WY_lab = case_when(
    water_year %in% c(2021, 2022) ~ "dry",
    water_year %in% c(2023) ~ "wet",
    water_year %in% c(2024) ~ "normal",
    TRUE ~ NA_character_  
  )) %>%
    group_by(site, date, catch) %>%
    summarise(across(everything(), mean, na.rm = TRUE), .groups = "drop")

N_ratio_plots <- ggplot(covariat_NS_ND%>%filter(water_year<2025), aes(x = (NO3_supply), y = (Ndemand), color = as.factor(water_year), shape=site)) +
  geom_point(size = 3, alpha = 0.85, position = position_dodge(width = 0.3)) +
    geom_point( aes(x = (NH4_supply), y = Ndemand, color = as.factor(water_year)),
                size = 3, alpha = 0.85, position = position_dodge(width = 0.3)) +
  geom_abline(slope = 1, intercept = 0, color = "black") +  # 1:1 line
    scale_color_viridis_d(option = "viridis",  name = "Water year") +
      scale_shape_manual(values = c(15,0,17,2), name = "Site") +
    scale_x_continuous(trans = "log", breaks = scales::log_breaks(base = 10)) + 
  scale_y_continuous(trans = "log", breaks = scales::log_breaks(base = 10),
                       labels = scales::label_number()) +
#    scale_x_continuous(trans = "log", breaks = c(0.001, 0.003, 0.1, 0.3, 1, 1.6)) +
 #     scale_y_continuous(trans = "log",  breaks = c(0.0001, 0.001, 0.003, 0.05, 0.1, 0.3)) +
 # xlim(0,1) +
 # ylim(0, 1) +
   ylab(expression(log(Nitrogen~demand)~(g~N~m^-2~d^-1))) +
     xlab(expression(log(Nitrogen~supply)~(g~N~m^-2~d^-1))) +
  theme_classic() 


NO3_supp_plots <- ggplot(covariat_NS_ND%>%filter(water_year<2025), aes(y = (NO3_supply_new), x = jday, color = as.factor(water_year), shape=site)) +
  geom_point(size = 2, alpha = 0.85, position = position_dodge(width = 0.3)) +
  geom_point( aes(y = log(NH4_supply_new+1), x = jday, color = as.factor(water_year), shape=site), 
                size = 2, alpha = 0.85, position = position_dodge(width = 0.3)) +
    scale_color_viridis_d(option = "viridis", name = "Water year") +  # Use _c for continuous data
#  ylim(0,1.50) +
   xlab(NULL) +
    scale_y_continuous(trans = "log", breaks = scales::log_breaks(base = 10)) +
  geom_smooth(aes(group = as.factor(water_year), fill = as.factor(water_year)), 
            se = TRUE, linewidth = 1, method = "gam", formula = y ~ s(x, k = 10), alpha = 0.1)+
     ylab(expression(log(Supply)~(g~N~m^-2~d^-1))) +
  theme_classic() +
      scale_x_continuous(
  limits = c(15, 285),
  breaks = seq(15, 285, by = 30)  
)+
      scale_fill_viridis_d(option = "viridis", name = "Water year") + 
  scale_shape_manual(values = c(15,0,17,2)) +
    theme(legend.position = "none") +
  facet_grid(catch~.)
# Remove legend

# Define threshold for high NO3 demand (above 3rd quartile)
high_Ndemand_threshold <- 0.075

N_demand_plot1 <- ggplot(covariat_NS_ND%>%filter(water_year<2025), aes(y = (Ndemand), x = jday, color = as.factor(water_year), shape = site)) +
  geom_point(size = 2, alpha = 0.85, position = position_dodge(width = 0.8)) +
  scale_color_viridis_d(option = "viridis", name = "Water year") +  # Use _c for continuous data
    scale_fill_viridis_d(option = "viridis", name = "Water year") +  # Use _c for continuous data
  xlab("Day of year") + 
    geom_smooth(aes(group = as.factor(water_year), fill = as.factor(water_year)), 
            se = TRUE, linewidth = 1, method = "gam", formula = y ~ s(x, k = 10), alpha = 0.1)+
    scale_y_continuous(trans = "log", breaks = scales::log_breaks(base = 10),
                         labels = scales::label_number()) +
 # geom_hline(yintercept = high_Ndemand_threshold, linetype = "dashed", color = "grey25") +
  scale_shape_manual(values = c(15, 0, 17, 2)) +
  ylab(expression(log(Demand)~(g~N~m^-2~d^-1))) +
  theme_classic() +
      scale_x_continuous(
  limits = c(15, 285),
  breaks = seq(15, 285, by = 30)  
)+
  theme(legend.position = "none")  +
    facet_grid(catch~.)

N_demand_plot1

```

### **Figure 5**


```{r, warning=F, size = 'small', echo=F,include=T, fig.width=12, fig.height=6}

n_s_grid <- ggarrange(
  NO3_supp_plots,
  N_demand_plot1,
  labels = c("b", "c"),
    align = c("v"),
  ncol = 1, nrow = 2,
  label.x = 0.91,  # Move label to the right
  label.y = 1,     # Keep label at the top
  hjust = 1,       # Right-align the label
  vjust = 1        # Top-align the label
)



N_ratio_plots <- N_ratio_plots + 
  theme(
    aspect.ratio = 1, 
    plot.margin = margin(10, 20, 10, 20),
    legend.position = "bottom"
  ) +
  guides(
    shape = guide_legend(nrow = 2),  # Shape legend on first line
    color = guide_legend(nrow = 2)   # Color legend on second line
  )

Ndyn_grid <- ggarrange(
  N_ratio_plots,
  n_s_grid,
  ncol = 2, nrow = 1,
  labels = c("a", ""),
  vjust = 7,
  label.x = 0.23,  
  #common.legend = TRUE, 
  #legend = "bottom",
  widths = c(1.3, 1.6)
)

Ndyn_grid


```

```{r, warning=F, size = 'small', echo=F, include=F, fig.width=9, fig.height=4}
# ggsave("/Users/kellyloria/Documents/Publications/CH1\ biogeochem\ linkages/Figs/Fig4_n_dyn.png", plot = Ndyn_grid, width = 10.75, height = 6.75, units = "in")

```


### Perform ANOVA for year differences in at each reach

##### GPP: 
```{r, warning=F, size = 'small', echo=T, include=T}
# Define the water years you want on the x-axis, including 2021
desired_years <- c("2021", "2022", "2023")

anova_n03_sup_bw <- aov(NO3_supply_new ~ as.factor(water_year), data = covariat_NS_ND%>%filter(site == "BWL", water_year %in% 2021:2023))
summary(anova_n03_sup_bw)

posthoc_n03 <- TukeyHSD(anova_n03_sup_bw)
posthoc_n03

#  there are no statistical diffs


anova_n03_sup_bw <- aov(NO3_supply_new ~ as.factor(water_year), data = covariat_NS_ND%>%filter(site == "BWU", water_year %in% 2021:2023))
summary(anova_n03_sup_bw)

posthoc_n03 <- TukeyHSD(anova_n03_sup_bw)
posthoc_n03

#  there are no statistically diffs

anova_n03_sup_gb <- aov(NO3_supply_new ~ as.factor(water_year), data = covariat_NS_ND%>%filter(site == "GBL", water_year %in% 2021:2023))
summary(anova_n03_sup_gb)

posthoc_n03 <- TukeyHSD(anova_n03_sup_gb)
posthoc_n03

#  there are no statistically diffs
```


### Annual N supply

### NO3 supply 


###

```{r, warning=F, size = 'small', echo=F, fig.width=5, include=FALSE,fig.height=4}

desired_years <- c("2021","2022","2023")

NO3_mean_diff_wet_dry <- covariat_NS_ND %>%
  filter(water_year %in% 2021:2023) %>%
  mutate(
    water_year = as.integer(water_year),
    year_group = case_when(
      water_year %in% c(2021, 2022) ~ "2021_2022",
      water_year == 2023            ~ "2023",
      TRUE                          ~ NA_character_
    )
  ) %>%
  filter(!is.na(year_group)) %>%
  group_by(site, year_group) %>%
  summarise(
    mean_NO3 = mean(NO3_supply_new, na.rm = TRUE),
    n = sum(!is.na(NO3_supply_new)),
    .groups = "drop"
  ) %>%
  tidyr::pivot_wider(
    names_from = year_group,
    values_from = c(mean_NO3, n)
  ) %>%
  mutate(
    # mean difference relative to 2023 (same sign convention as your statement: "rose" => positive)
    delta_wet_dry = mean_NO3_2023- mean_NO3_2021_2022,
    # percent difference relative to 2023
    pct_change = round(100 * (mean_NO3_2023- mean_NO3_2021_2022) / mean_NO3_2021_2022)
  ) %>%
  arrange(site)

NO3_mean_diff_wet_dry
```


```{r, warning=F, size = 'small', echo=F, fig.width=5, include=FALSE,fig.height=4}

library(dplyr)
library(ggplot2)
library(multcompView)

desired_years <- c("2021","2022","2023")

make_site_plot_yearonly <- function(site_id, y_max = 2.0, label_pad = 0.05) {

  df <- covariat_NS_ND %>%
    filter(site == site_id, water_year %in% 2021:2023) %>%
    mutate(water_year = factor(as.character(water_year), levels = desired_years))

  # ANOVA (year only)
  fit <- aov(NO3_supply_new ~ water_year, data = df)
  tuk <- TukeyHSD(fit)
  letters <- multcompLetters4(fit, tuk)

  letters_df <- data.frame(
    water_year = names(letters[[1]]$Letters),
    letters    = letters[[1]]$Letters
  ) %>%
    mutate(water_year = factor(water_year, levels = desired_years))

  # dynamic y position for letters (per site)
  y_lab <- min(y_max, max(df$NO3_supply_new, na.rm = TRUE) + label_pad)

  p <- ggplot(df, aes(x = water_year, y = NO3_supply_new)) +
    geom_boxplot(alpha = 0.5, outlier.shape = NA,
                 aes(fill = catch, color = catch)) +
    scale_color_manual(values = catch_colors) +
    scale_fill_manual(values = catch_colors) +
    labs(x = NULL, y = NULL, fill = "Catchment", color = "Catchment") +
    coord_cartesian(ylim = c(0, y_max)) +
    theme_classic() +
    geom_text(
      data = letters_df,
      aes(x = water_year, y = y_lab, label = letters),
      inherit.aes = FALSE,
      size = 3
    )

  list(plot = p, anova = summary(fit), tukey = tuk)
}


library(multcompView)
library(dplyr)

make_letters_from_tukey <- function(tukey, term, alpha = 0.10) {

  pvals <- tukey[[term]][, "p adj"]
  names(pvals) <- rownames(tukey[[term]])

  # TRUE = significantly different
  sig <- pvals < alpha

  cld <- multcompLetters(sig)

  data.frame(
    water_year = names(cld$Letters),
    letters = cld$Letters,
    stringsAsFactors = FALSE
  )
}

# build letters using alpha = 0.10
letters_df <- make_letters_from_tukey(
  tukey = res_GBU$tukey,
  term  = "water_year",
  alpha = 0.10
) %>%
  mutate(water_year = factor(water_year, levels = desired_years))



res_BWL <- make_site_plot_yearonly("BWL")
plot_Nsupply_BWL <- res_BWL$plot

res_BWU <- make_site_plot_yearonly("BWU")
plot_Nsupply_BWU <- res_BWU$plot

res_GBL <- make_site_plot_yearonly("GBL")
plot_Nsupply_GBL <- res_GBL$plot

res_GBU <- make_site_plot_yearonly("GBU")
plot_Nsupply_GBU <- res_GBU$plot


# Build all site results (letters computed consistently at alpha=0.10)
res_BWL <- make_site_plot_yearonly("BWL", alpha_letters = 0.10)
plot_Nsupply_BWL <- res_BWL$plot

res_BWU <- make_site_plot_yearonly("BWU", alpha_letters = 0.10)
plot_Nsupply_BWU <- res_BWU$plot

res_GBL <- make_site_plot_yearonly("GBL", alpha_letters = 0.10)
plot_Nsupply_GBL <- res_GBL$plot

res_GBU <- make_site_plot_yearonly("GBU", alpha_letters = 0.10)
plot_Nsupply_GBU <- res_GBU$plot

```

```{r, warning=F, size = 'small', echo=T, fig.width=5, include=FALSE,fig.height=4}

desired_years <- c("2021","2022","2023")

nh4_mean_diff_wet_dry <- covariat_NS_ND %>%
  filter(water_year %in% 2021:2023) %>%
  mutate(
    water_year = as.integer(water_year),
    year_group = case_when(
      water_year %in% c(2021, 2022) ~ "2021_2022",
      water_year == 2023            ~ "2023",
      TRUE                          ~ NA_character_
    )
  ) %>%
  filter(!is.na(year_group)) %>%
  group_by(site, year_group) %>%
  summarise(
    mean_NH4 = mean(NH4_supply_new, na.rm = TRUE),
    n = sum(!is.na(NH4_supply_new)),
    .groups = "drop"
  ) %>%
  tidyr::pivot_wider(
    names_from = year_group,
    values_from = c(mean_NH4, n)
  ) %>%
  mutate(
    # mean difference relative to 2023 (same sign convention as your statement: "rose" => positive)
    delta_wet_dry = mean_NH4_2023- mean_NH4_2021_2022,
    # percent difference relative to 2023
    pct_change = round(100 * (mean_NH4_2023- mean_NH4_2021_2022) / mean_NH4_2021_2022)
  ) %>%
  arrange(site)

nh4_mean_diff_wet_dry
```

#### NH4 supply 

```{r, warning=F, size = 'small', echo=F, fig.width=5, include=FALSE,fig.height=4}


library(dplyr)
library(ggplot2)
library(multcompView)

desired_years <- c("2021","2022","2023")

make_letters_from_tukey <- function(tukey, term, alpha = 0.10) {
  pvals <- tukey[[term]][, "p adj"]
  names(pvals) <- rownames(tukey[[term]])

  sig <- pvals < alpha
  cld <- multcompLetters(sig)

  data.frame(
    water_year = names(cld$Letters),
    letters = cld$Letters,
    stringsAsFactors = FALSE
  )
}

make_site_plot_yearonly <- function(site_id, y_max = 0.75, label_pad = 0.05, alpha_letters = 0.10) {

  df <- covariat_NS_ND %>%
    filter(site == site_id, water_year %in% 2021:2023) %>%
    mutate(water_year = factor(as.character(water_year), levels = desired_years))

  # Safety check (helps avoid confusing Tukey errors if a year is missing)
  if (nrow(df) == 0) stop(paste("No data for site:", site_id))
  if (nlevels(droplevels(df$water_year)) < 2) stop(paste("Need >= 2 water years for site:", site_id))

  # ANOVA (year only) -- within this site only
  fit <- aov(NH4_supply_new ~ water_year, data = df)

  # Tukey for year factor
  tuk <- TukeyHSD(fit, which = "water_year")

  letters_df <- make_letters_from_tukey(tuk, term = "water_year", alpha = alpha_letters) %>%
    mutate(water_year = factor(water_year, levels = desired_years))

  y_lab <- min(y_max, max(df$NH4_supply_new, na.rm = TRUE) + label_pad)

  p <- ggplot(df, aes(x = water_year, y = NH4_supply_new)) +
    geom_boxplot(alpha = 0.5, outlier.shape = NA,
                 aes(fill = catch, color = catch)) +
    scale_color_manual(values = catch_colors) +
    scale_fill_manual(values = catch_colors) +
    labs(x = NULL, y = NULL, fill = "Catchment", color = "Catchment") +
    coord_cartesian(ylim = c(0, y_max)) +
    ylab(expression(NH[4]~"supply"~(g~N~m^-2~d^-1))) +
    theme_classic() +
    geom_text(
      data = letters_df,
      aes(x = water_year, y = y_lab, label = letters),
      inherit.aes = FALSE,
      size = 3
    )

  list(plot = p, anova = summary(fit), tukey = tuk, letters = letters_df, data = df)
}


# Build all site results (letters computed consistently at alpha=0.10)
res_BWL <- make_site_plot_yearonly("BWL", alpha_letters = 0.10)
plot_NH4supply_BWL <- res_BWL$plot

res_BWU <- make_site_plot_yearonly("BWU", alpha_letters = 0.05)
plot_NH4supply_BWU <- res_BWU$plot

res_GBL <- make_site_plot_yearonly("GBL", alpha_letters = 0.10)
plot_NH4supply_GBL <- res_GBL$plot

res_GBU <- make_site_plot_yearonly("GBU", alpha_letters = 0.10)
plot_NH4supply_GBU <- res_GBU$plot

```



### N demand

```{r, warning=F, size = 'small', echo=F, fig.width=5, include=FALSE,fig.height=4}

desired_years <- c("2021","2022","2023")

Ndemand_mean_diff_wet_dry <- covariat_NS_ND %>%
  filter(water_year %in% 2021:2023) %>%
  mutate(
    water_year = as.integer(water_year),
    year_group = case_when(
      water_year %in% c(2021, 2022) ~ "2021_2022",
      water_year == 2023            ~ "2023",
      TRUE                          ~ NA_character_
    )
  ) %>%
  filter(!is.na(year_group)) %>%
  group_by(site, year_group) %>%
  summarise(
    mean_Ndemand = mean(Ndemand, na.rm = TRUE),
    n = sum(!is.na(Ndemand)),
    .groups = "drop"
  ) %>%
  tidyr::pivot_wider(
    names_from = year_group,
    values_from = c(mean_Ndemand, n)
  ) %>%
  mutate(
    # mean difference relative to 2023 (same sign convention as your statement: "rose" => positive)
    delta_wet_dry = mean_Ndemand_2023- mean_Ndemand_2021_2022,
    # percent difference relative to 2023
    pct_change = round(100 * (mean_Ndemand_2023- mean_Ndemand_2021_2022) / mean_Ndemand_2021_2022)
  ) %>%
  arrange(site)

Ndemand_mean_diff_wet_dry

```

```{r, warning=F, size = 'small', echo=F, fig.width=5, include=FALSE,fig.height=4}

library(dplyr)
library(ggplot2)
library(multcompView)


desired_years <- c("2021","2022","2023")

make_letters_from_tukey <- function(tukey, term, alpha = 0.10) {
  pvals <- tukey[[term]][, "p adj"]
  names(pvals) <- rownames(tukey[[term]])

  sig <- pvals < alpha
  cld <- multcompLetters(sig)

  data.frame(
    water_year = names(cld$Letters),
    letters = cld$Letters,
    stringsAsFactors = FALSE
  )
}

make_site_plot_yearonly <- function(site_id, y_max = 0.75, label_pad = 0.05, alpha_letters = 0.10) {

  df <- covariat_NS_ND %>%
    filter(site == site_id, water_year %in% 2021:2023) %>%
    mutate(water_year = factor(as.character(water_year), levels = desired_years))

  # Safety check (helps avoid confusing Tukey errors if a year is missing)
  if (nrow(df) == 0) stop(paste("No data for site:", site_id))
  if (nlevels(droplevels(df$water_year)) < 2) stop(paste("Need >= 2 water years for site:", site_id))

  # ANOVA (year only) -- within this site only
  fit <- aov(Ndemand ~ water_year, data = df)

  # Tukey for year factor
  tuk <- TukeyHSD(fit, which = "water_year")

  letters_df <- make_letters_from_tukey(tuk, term = "water_year", alpha = alpha_letters) %>%
    mutate(water_year = factor(water_year, levels = desired_years))

  y_lab <- min(y_max, max(df$Ndemand, na.rm = TRUE) + label_pad)

  p <- ggplot(df, aes(x = water_year, y = Ndemand)) +
    geom_boxplot(alpha = 0.5, outlier.shape = NA,
                 aes(fill = catch, color = catch)) +
    scale_color_manual(values = catch_colors) +
    scale_fill_manual(values = catch_colors) +
    labs(x = NULL, y = NULL, fill = "Catchment", color = "Catchment") +
    coord_cartesian(ylim = c(0, y_max)) +
    ylab(expression(NH[4]~"supply"~(g~N~m^-2~d^-1))) +
    theme_classic() +
    geom_text(
      data = letters_df,
      aes(x = water_year, y = y_lab, label = letters),
      inherit.aes = FALSE,
      size = 3
    )

  list(plot = p, anova = summary(fit), tukey = tuk, letters = letters_df, data = df)
}



# Build all site results (letters computed consistently at alpha=0.10)
res_BWL <- make_site_plot_yearonly("BWL", alpha_letters = 0.10)
plot_Ndemand_BWL <- res_BWL$plot

res_BWU <- make_site_plot_yearonly("BWU", alpha_letters = 0.10)
plot_Ndemand_BWU <- res_BWU$plot

res_GBL <- make_site_plot_yearonly("GBL", alpha_letters = 0.10)
plot_Ndemand_GBL <- res_GBL$plot

res_GBU <- make_site_plot_yearonly("GBU", alpha_letters = 0.10)
plot_Ndemand_GBU <- res_GBU$plot

```


```{r, warning=F, size = 'small', echo=F, fig.width=8, include=FALSE,fig.height=6}

Ndyn_annual_grid <- ggarrange(
  plot_Nsupply_BWL,
  plot_Nsupply_BWU,
  plot_Nsupply_GBL,
  plot_Nsupply_GBU,
  plot_NH4supply_BWL,
  plot_NH4supply_BWU,
  plot_NH4supply_GBL,
  plot_NH4supply_GBU,
  plot_Ndemand_BWL,
  plot_Ndemand_BWU,
  plot_Ndemand_GBL,
  plot_Ndemand_GBU,
  align = "v",
    ncol = 4, nrow = 3,
    common.legend = TRUE, 
   legend = "right")


 Ndyn_annual_grid 
  
  
```


```{r, warning=F, size = 'small', echo=F, include=FALSE}
# ggsave("/Users/kellyloria/Documents/Publications/CH1\ biogeochem\ linkages/Figs/Figure6_annualNtrend.png", plot = Ndyn_annual_grid, width = 8, height = 6.5, units = "in")

```

#### SI figuress ###
### Comparable cumulative metabolism
Where days that the model can't identify GPP (in green) or ER (orange) but there is DO, we then assume the metabolism (GPP/ER) to be 0 


```{r, warning=F, size = 'small', echo=F, include=T,fig.width=9, fig.height=2}
# Filter the dataset to only include rows where do.obs_m or GPP_mean are not NA
plot_data_date <- covariat_datq %>%
 dplyr::filter(!is.na(do.obs_m))

plot_data_DO <- covariat_datq %>%
  dplyr::filter(site=="BWL", !is.na(do.obs_m)) %>%
  dplyr::select(date, do.obs_m, GPP_mean) %>%
  dplyr::mutate(
    has_do = !is.na(do.obs_m),
    has_GPP = !is.na(GPP_mean),
    plot_GPP = dplyr::if_else(is.na(GPP_mean), 0, GPP_mean),
    yday = lubridate::yday(date),
    year = lubridate::year(date)
  )


# Identify the unique yday values for each year
yday_2021 <- unique(plot_data_DO$yday[plot_data_DO$year == 2021])
yday_2022 <- unique(plot_data_DO$yday[plot_data_DO$year == 2022])
yday_2023 <- unique(plot_data_DO$yday[plot_data_DO$year == 2023])

# Find the common yday values across all three years
common_yday <- Reduce(intersect, list(yday_2021, yday_2022, yday_2023))

# Filter the dataframe for only those common yday values
filtered_data <- plot_data_DO %>%
 dplyr::filter(yday %in% common_yday & year %in% c(2021, 2022, 2023))

filtered_data_cs <- filtered_data %>%
  dplyr::group_by(year) %>%
  dplyr::arrange(yday, .by_group = TRUE) %>%
  dplyr::mutate(GPP_cumsum = cumsum(plot_GPP)) %>%
  dplyr::ungroup()



# Determine the date range
date_range <- range(plot_data_date$date, na.rm = TRUE)

# Create the number line plot
templt_1 <- ggplot(filtered_data, aes(x = yday)) +
  #geom_segment(aes(x = date_range[1], xend = date_range[2], y = 0, yend = 0), linewidth = 0.2) + # Main line
  geom_point(data =dplyr::filter(filtered_data, has_do), aes(y = 0.095), alpha=0.8, color = "black", size = 1) + # DO presence tick marks
  geom_point(data =dplyr::filter(filtered_data, has_GPP), aes(y = 0.090), alpha= 0.8, color = "#579467", size = 1) + # GPP presence tick marks
  scale_y_continuous(name = "", breaks = NULL) +
  theme_classic() + xlab(NULL) +
    labs(title = "BW Lower - GPP") +facet_grid(year~.)
templt_1
```

```{r, warning=F, size = 'small', echo=F, include=F}
#####
date_datf_plt <- date_datf %>%
  mutate(yday=yday(date),
         year=year(date))

date_datf_plt_bw <- date_datf_plt %>%
 dplyr::filter(site=="BWL" & year <2024) %>%
  left_join(filtered_data_cs, by=c("yday", "year", "date"))

BWL_plot <- ggplot(date_datf_plt_bw, aes(x = yday, y = GPP_cumsum, color = factor(year))) +
  geom_line(size = 1, alpha=0.95) + 
  labs(x = "Day of Water Year", color = "Year", 
       title = "BW Lower") +
  ylab(expression(GPP~(g~O[2]~m^-2~yr^-1))) +
  xlab(NULL) +
  scale_color_manual(values=c("#440154", "#3B528B", "#4bcc94")) +
 #   scale_color_viridis_d(option = "viridis",  name = "Year") +
  theme_classic() +
   xlim(91, 335)
#  xlim(115, 290)

BWL_plot

# Compute the maximum cumulative GPP for each year
date_datf_plt_sum <- date_datf_plt_bw %>%
  group_by(year) %>%
  dplyr::summarise(T_gpp = max(GPP_cumsum, na.rm = TRUE)) %>%
  mutate(percent_change = (T_gpp -T_gpp[year == 2023]) / T_gpp * 100)


dry_mean <- date_datf_plt_sum %>%
  dplyr::filter(year %in% c(2021, 2022)) %>%
  dplyr::summarise(dry_mean = mean(T_gpp)) %>%
  pull(dry_mean)


wet_2023 <- date_datf_plt_sum %>%
  dplyr::filter(year == 2023) %>%
  pull(T_gpp)


tibble(
  dry_mean = dry_mean,
  wet_2023 = wet_2023,
  diff = wet_2023 - dry_mean,
  pct_decrease = (wet_2023 - dry_mean) / dry_mean * 100
)


```

## Wet to dry 102.0758


```{r, warning=F, size = 'small', echo=F, include=T,fig.width=9, fig.height=2}
# Filter the dataset to only include rows where do.obs_m or GPP_mean are not NA
plot_data_date <- covariat_datq %>%
 dplyr::filter(!is.na(do.obs_m))

plot_data_DO <- covariat_datq %>%
   dplyr::filter(site=="BWL") %>%
 dplyr::filter(!is.na(do.obs_m)) %>%
   dplyr::select(date, do.obs_m, ER_mean) %>%
  mutate(has_do = !is.na(do.obs_m), 
         has_ER = !is.na(ER_mean),
         ER_abs = (ER_mean*-1),
         plot_ER = ifelse(is.na(ER_abs), 0, ER_abs),
         yday=yday(date),
         year=year(date))



# Identify the unique yday values for each year
yday_2021 <- unique(plot_data_DO$yday[plot_data_DO$year == 2021])
yday_2022 <- unique(plot_data_DO$yday[plot_data_DO$year == 2022])
yday_2023 <- unique(plot_data_DO$yday[plot_data_DO$year == 2023])

# Find the common yday values across all three years
common_yday <- Reduce(intersect, list(yday_2021, yday_2022, yday_2023))

# Filter the dataframe for only those common yday values
filtered_data <- plot_data_DO %>%
 dplyr::filter(yday %in% common_yday & year %in% c(2021, 2022, 2023))

filtered_data_cs <- filtered_data %>%
  dplyr::group_by(year) %>%
  dplyr::arrange(yday, .by_group = TRUE) %>%
  dplyr::mutate(ER_cumsum = cumsum(plot_ER)) %>%
  dplyr::ungroup()

# Determine the date range
date_range <- range(plot_data_date$date, na.rm = TRUE)

# Create the number line plot
templt <- ggplot(filtered_data, aes(x = yday)) +
  #geom_segment(aes(x = date_range[1], xend = date_range[2], y = 0, yend = 0), linewidth = 0.2) + # Main line
  geom_point(data =dplyr::filter(filtered_data, has_do), aes(y = 0.095), alpha=0.8, color = "black", size = 1) + # DO presence tick marks
  geom_point(data =dplyr::filter(filtered_data, has_ER), aes(y = 0.090), alpha= 0.8, color = "chocolate", size = 1) + # GPP presence tick marks
  scale_y_continuous(name = "", breaks = NULL) +
  theme_classic() + xlab(NULL) +
    labs(title = "BW Lower - ER") +facet_grid(year~.)
templt
```

```{r, warning=F, size = 'small', echo=F, include=F}
#####
date_datf_plt <- date_datf %>%
  mutate(yday=yday(date),
         year=year(date))

date_datf_plt_bw <- date_datf_plt %>%
 dplyr::filter(site=="BWL" & year <2024) %>%
  left_join(filtered_data_cs, by=c("yday", "year", "date"))

BWL_plot1 <- ggplot(date_datf_plt_bw, aes(x = yday, y = ER_cumsum, color = factor(year))) +
  geom_line(size = 1, alpha=0.95) + 
      ylim(0,1500)+
  labs(x = "Day of Water Year", color = "Year") +
  ylab(expression("|"~ER~"|"~(g~O[2]~m^-2~yr^-1))) +
  scale_color_manual(values=c("#440154", "#3B528B", "#4bcc94")) +
 #   scale_color_viridis_d(option = "viridis",  name = "Year") +
  theme_classic() +
    xlab(NULL) +
     xlim(91, 335)
#  xlim(115, 290)


# Compute the maximum cumulative GPP for each year
date_datf_plt_sum <- date_datf_plt_bw %>%
  group_by(year) %>%
  dplyr::summarise(T_cm = max(ER_cumsum, na.rm = TRUE)) %>%
  mutate(percent_change = (T_cm -T_cm[year == 2023]) / T_cm * 100)

dry_mean <- date_datf_plt_sum %>%
  dplyr::filter(year %in% c(2021, 2022)) %>%
  dplyr::summarise(dry_mean = mean(T_cm)) %>%
  pull(dry_mean)


wet_2023 <- date_datf_plt_sum %>%
  dplyr::filter(year == 2023) %>%
  pull(T_cm)


tibble(
  dry_mean = dry_mean,
  wet_2023 = wet_2023,
  diff = wet_2023 - dry_mean,
  pct_decrease = (wet_2023 - dry_mean) / dry_mean * 100
)

```




```{r, warning=F, size = 'small', echo=F, include=T,fig.width=9, fig.height=2}
# Filter the dataset to only include rows where do.obs_m or GPP_mean are not NA
plot_data_date <- covariat_datq %>%
 dplyr::filter(!is.na(do.obs_m))

plot_data_DO <- covariat_datq %>%
   dplyr::filter(site=="BWU") %>%
 dplyr::filter(!is.na(do.obs_m)) %>%
   dplyr::select(date, do.obs_m, GPP_mean) %>%
  mutate(has_do = !is.na(do.obs_m), 
         has_GPP = !is.na(GPP_mean),
         plot_GPP = ifelse(is.na(GPP_mean), 0, GPP_mean),
         yday=yday(date),
         year=year(date))

# Identify the unique yday values for each year
yday_2021 <- unique(plot_data_DO$yday[plot_data_DO$year == 2021])
yday_2022 <- unique(plot_data_DO$yday[plot_data_DO$year == 2022])
yday_2023 <- unique(plot_data_DO$yday[plot_data_DO$year == 2023])

# Find the common yday values across all three years
common_yday <- Reduce(intersect, list(yday_2021, yday_2022, yday_2023))

# Filter the dataframe for only those common yday values
filtered_data <- plot_data_DO %>%
 dplyr::filter(yday %in% common_yday & year %in% c(2021, 2022, 2023))

filtered_data_cs <- filtered_data %>%
  dplyr::group_by(year) %>%
  dplyr::arrange(yday, .by_group = TRUE) %>%
  dplyr::mutate(GPP_cumsum = cumsum(plot_GPP)) %>%
  dplyr::ungroup()

# Determine the date range
date_range <- range(plot_data_date$date, na.rm = TRUE)

# Create the number line plot
templt <- ggplot(filtered_data, aes(x = yday)) +
  #geom_segment(aes(x = date_range[1], xend = date_range[2], y = 0, yend = 0), linewidth = 0.2) + # Main line
  geom_point(data =dplyr::filter(filtered_data, has_do), aes(y = 0.095), alpha=0.8, color = "black", size = 1) + # DO presence tick marks
  geom_point(data =dplyr::filter(filtered_data, has_GPP), aes(y = 0.090), alpha= 0.8, color = "#579467", size = 1) + # GPP presence tick marks
  scale_y_continuous(name = "", breaks = NULL) +
  theme_classic() + xlab(NULL) +
    labs(title = "BW Upper - GPP") +facet_grid(year~.)
templt
```


```{r, warning=F, size = 'small', echo=F, include=F}
#####
date_datf_plt <- date_datf %>%
  mutate(yday=yday(date),
         year=year(date))

date_datf_plt_bw <- date_datf_plt %>%
 dplyr::filter(site=="BWU" & year <2024) %>%
  left_join(filtered_data_cs, by=c("yday", "year", "date"))

BWU_plot <- ggplot(date_datf_plt_bw, aes(x = yday, y = GPP_cumsum, color = factor(year))) +
  geom_line(size = 1, alpha=0.95) + 
  labs(x = "Day of Water Year", color = "Year", 
       title = "BW Upper") +
  ylab(expression(GPP~(g~O[2]~m^-2~yr^-1))) +
  ylim(0,400) +
  scale_color_manual(values=c("#440154", 
                              "#3B528B", 
                              "#4bcc94")) +
 #   scale_color_viridis_d(option = "viridis",  name = "Year") +
  theme_classic() +
    xlab(NULL) +
       xlim(91, 335)



# Compute the maximum cumulative GPP for each year
date_datf_plt_sum <- date_datf_plt_bw %>%
  group_by(year) %>%
  dplyr::summarise(T_cm = max(GPP_cumsum, na.rm = TRUE)) %>%
  mutate(percent_change = (T_cm -T_cm[year == 2023]) / T_cm * 100)

dry_mean <- date_datf_plt_sum %>%
  dplyr::filter(year %in% c(2021, 2022)) %>%
  dplyr::summarise(dry_mean = mean(T_cm)) %>%
  pull(dry_mean)


wet_2023 <- date_datf_plt_sum %>%
  dplyr::filter(year == 2023) %>%
  pull(T_cm)


tibble(
  dry_mean = dry_mean,
  wet_2023 = wet_2023,
  diff = wet_2023 - dry_mean,
  pct_decrease = (wet_2023 - dry_mean) / dry_mean * 100
)


```




```{r, warning=F, size = 'small', echo=F, include=T,fig.width=9, fig.height=2}
# Filter the dataset to only include rows where do.obs_m or GPP_mean are not NA
plot_data_date <- covariat_datq %>%
 dplyr::filter(!is.na(do.obs_m))

plot_data_DO <- covariat_datq %>%
   dplyr::filter(site=="BWU") %>%
 dplyr::filter(!is.na(do.obs_m)) %>%
   dplyr::select(date, do.obs_m, ER_mean) %>%
  mutate(has_do = !is.na(do.obs_m), 
         has_ER = !is.na(ER_mean),
         ER_abs = (ER_mean*-1),
         plot_ER = ifelse(is.na(ER_abs), 0, ER_abs),
         yday=yday(date),
         year=year(date))

# Identify the unique yday values for each year
yday_2021 <- unique(plot_data_DO$yday[plot_data_DO$year == 2021])
yday_2022 <- unique(plot_data_DO$yday[plot_data_DO$year == 2022])
yday_2023 <- unique(plot_data_DO$yday[plot_data_DO$year == 2023])

# Find the common yday values across all three years
common_yday <- Reduce(intersect, list(yday_2021, yday_2022, yday_2023))

# Filter the dataframe for only those common yday values
filtered_data <- plot_data_DO %>%
 dplyr::filter(yday %in% common_yday & year %in% c(2021, 2022, 2023))

filtered_data_cs <- filtered_data %>%
  dplyr::group_by(year) %>%
  dplyr::arrange(yday, .by_group = TRUE) %>%
  dplyr::mutate(ER_cumsum = cumsum(plot_ER)) %>%
  dplyr::ungroup()

# Determine the date range
date_range <- range(plot_data_date$date, na.rm = TRUE)

# Create the number line plot
templt <- ggplot(filtered_data, aes(x = yday)) +
  #geom_segment(aes(x = date_range[1], xend = date_range[2], y = 0, yend = 0), linewidth = 0.2) + # Main line
  geom_point(data =dplyr::filter(filtered_data, has_do), aes(y = 0.095), alpha=0.8, color = "black", size = 1) + # DO presence tick marks
  geom_point(data =dplyr::filter(filtered_data, has_ER), aes(y = 0.090), alpha= 0.8, color = "chocolate", size = 1) + # GPP presence tick marks
  scale_y_continuous(name = "", breaks = NULL) +
  theme_classic() + xlab(NULL) +
    labs(title = "BW Upper - ER") +facet_grid(year~.)
templt
```

```{r, warning=F, size = 'small', echo=F, include=F}
#####
date_datf_plt <- date_datf %>%
  mutate(yday=yday(date),
         year=year(date))

date_datf_plt_bw <- date_datf_plt %>%
 dplyr::filter(site=="BWU" & year <2024) %>%
  left_join(filtered_data_cs, by=c("yday", "year", "date"))

BWU_plot1 <- ggplot(date_datf_plt_bw, aes(x = yday, y = ER_cumsum, color = factor(year))) +
  geom_line(size = 1, alpha=0.95) + 
  labs(x = "Day of Water Year", color = "Year") +
  ylab(expression("|"~ER~"|"~(g~O[2]~m^-2~yr^-1))) +
  scale_color_manual(values=c("#440154", "#3B528B", "#4bcc94")) +
 #   scale_color_viridis_d(option = "viridis",  name = "Year") +
  theme_classic() +
        ylim(0,1500)+
    xlab(NULL) +
       xlim(91, 335)

  #xlim(185, 250)


# Compute the maximum cumulative GPP for each year
date_datf_plt_sum <- date_datf_plt_bw %>%
  group_by(year) %>%
 dplyr::summarise(T_cm = max(ER_cumsum, na.rm = TRUE)) %>%
  mutate(percent_change = (T_cm -T_cm[year == 2023]) / T_cm * 100)


dry_mean <- date_datf_plt_sum %>%
  dplyr::filter(year %in% c(2021, 2022)) %>%
  dplyr::summarise(dry_mean = mean(T_cm)) %>%
  pull(dry_mean)


wet_2023 <- date_datf_plt_sum %>%
  dplyr::filter(year == 2023) %>%
  pull(T_cm)


tibble(
  dry_mean = dry_mean,
  wet_2023 = wet_2023,
  diff = wet_2023 - dry_mean,
  pct_decrease = (wet_2023 - dry_mean) / dry_mean * 100
)


```


```{r, warning=F, size = 'small', echo=F, include=T,fig.width=9, fig.height=2}
# Filter the dataset to only include rows where do.obs_m or GPP_mean are not NA
plot_data_date <- covariat_datq %>%
 dplyr::filter(!is.na(do.obs_m))

plot_data_DO <- covariat_datq %>%
   dplyr::filter(site=="GBL") %>%
 dplyr::filter(!is.na(do.obs_m)) %>%
   dplyr::select(date, do.obs_m, GPP_mean) %>%
  mutate(has_do = !is.na(do.obs_m), 
         has_GPP = !is.na(GPP_mean),
         plot_GPP = ifelse(is.na(GPP_mean), 0, GPP_mean),
         yday=yday(date),
         year=year(date))

# Identify the unique yday values for each year
yday_2021 <- unique(plot_data_DO$yday[plot_data_DO$year == 2021])
yday_2022 <- unique(plot_data_DO$yday[plot_data_DO$year == 2022])
yday_2023 <- unique(plot_data_DO$yday[plot_data_DO$year == 2023])

# Find the common yday values across all three years
common_yday <- Reduce(intersect, list(yday_2021, 
                                      yday_2022, 
                                      yday_2023))

# Filter the dataframe for only those common yday values
filtered_data <- plot_data_DO %>%
 dplyr::filter(yday %in% common_yday & year %in% c(2021, 
                                             2022, 
                                             2023))

filtered_data_cs <- filtered_data %>%
  dplyr::group_by(year) %>%
  dplyr::arrange(yday, .by_group = TRUE) %>%
  dplyr::mutate(GPP_cumsum = cumsum(plot_GPP)) %>%
  dplyr::ungroup()

# Determine the date range
date_range <- range(plot_data_date$date, na.rm = TRUE)

# Create the number line plot
templt <- ggplot(filtered_data, aes(x = yday)) +
  #geom_segment(aes(x = date_range[1], xend = date_range[2], y = 0, yend = 0), linewidth = 0.2) + # Main line
  geom_point(data =dplyr::filter(filtered_data, has_do), aes(y = 0.095), alpha=0.8, color = "black", size = 1) + # DO presence tick marks
  geom_point(data =dplyr::filter(filtered_data, has_GPP), aes(y = 0.090), alpha= 0.8, color = "#579467", size = 1) + # GPP presence tick marks
  scale_y_continuous(name = "", breaks = NULL) +
  theme_classic() + xlab(NULL) +
    labs(title = "GB Lower - GPP") +facet_grid(year~.)
templt
```

```{r, warning=F, size = 'small', echo=F, include=F}
#####
date_datf_plt <- date_datf %>%
  mutate(yday=yday(date),
         year=year(date))

date_datf_plt_gb <- date_datf_plt %>%
 dplyr::filter(site=="GBL" & year <2024) %>%
  left_join(filtered_data_cs, by=c("yday", "year", "date"))

GBL_plot <- ggplot(date_datf_plt_gb, aes(x = yday, y = GPP_cumsum, color = factor(year))) +
  geom_line(size = 1, alpha=0.95) +
  ylim(0,30) +
  labs(x = "Day of Water Year", color = "Year", 
       title = "GB Lower") +
  ylab(expression(GPP~(g~O[2]~m^-2~yr^-1))) +
    xlab(NULL) +
  scale_color_manual(values=c("#440154", "#3B528B", "#4bcc94")) +
 #   scale_color_viridis_d(option = "viridis",  name = "Year") +
  theme_classic() + xlim(91, 335)


# Compute the maximum cumulative GPP for each year
date_datf_plt_sum <- date_datf_plt_gb %>%
  group_by(year) %>%
 dplyr::summarise(T_cm = max(GPP_cumsum, na.rm = TRUE)) %>%
  mutate(percent_change = (T_cm -T_cm[year == 2023]) / T_cm * 100)


date_datf_plt_sum <- date_datf_plt_gb %>%
  group_by(year) %>%
 dplyr::summarise(T_cm = max(GPP_cumsum, na.rm = TRUE)) %>%
  mutate(percent_change = (T_cm[year == 2023]-T_cm) / T_cm[year == 2023] * 100)

dry_mean <- date_datf_plt_sum %>%
  dplyr::filter(year %in% c(2021, 2022)) %>%
  dplyr::summarise(dry_mean = mean(T_cm)) %>%
  pull(dry_mean)

wet_2023 <- date_datf_plt_sum %>%
  dplyr::filter(year == 2023) %>%
  pull(T_cm)

tibble(
  dry_mean = dry_mean,
  wet_2023 = wet_2023,
  diff = wet_2023 - dry_mean,
  pct_decrease = (wet_2023 - dry_mean) / dry_mean * 100
)

```


```{r, warning=F, size = 'small', echo=F, include=T,fig.width=9, fig.height=2}
# Filter the dataset to only include rows where do.obs_m or GPP_mean are not NA
plot_data_date <- covariat_datq %>%
 dplyr::filter(!is.na(do.obs_m))

plot_data_DO <- covariat_datq %>%
   dplyr::filter(site=="GBL") %>%
 dplyr::filter(!is.na(do.obs_m)) %>%
   dplyr::select(date, do.obs_m, ER_mean) %>%
  mutate(has_do = !is.na(do.obs_m), 
         has_ER = !is.na(ER_mean),
         ER_abs = (ER_mean*-1),
         plot_ER = ifelse(is.na(ER_abs), 0, ER_abs),
         yday=yday(date),
         year=year(date))

# Identify the unique yday values for each year
yday_2021 <- unique(plot_data_DO$yday[plot_data_DO$year == 2021])
yday_2022 <- unique(plot_data_DO$yday[plot_data_DO$year == 2022])
yday_2023 <- unique(plot_data_DO$yday[plot_data_DO$year == 2023])

# Find the common yday values across all three years
common_yday <- Reduce(intersect, list(yday_2021, yday_2022, yday_2023))

# Filter the dataframe for only those common yday values
filtered_data <- plot_data_DO %>%
 dplyr::filter(yday %in% common_yday & year %in% c(2021, 2022, 2023))


filtered_data_cs <- filtered_data %>%
  dplyr::group_by(year) %>%
  dplyr::arrange(yday, .by_group = TRUE) %>%
  dplyr::mutate(ER_cumsum = cumsum(plot_ER)) %>%
  dplyr::ungroup()


# Determine the date range
date_range <- range(plot_data_date$date, na.rm = TRUE)

# Create the number line plot
templt <- ggplot(filtered_data, aes(x = yday)) +
  #geom_segment(aes(x = date_range[1], xend = date_range[2], y = 0, yend = 0), linewidth = 0.2) + # Main line
  geom_point(data =dplyr::filter(filtered_data, has_do), aes(y = 0.095), alpha=0.8, color = "black", size = 1) + # DO presence tick marks
  geom_point(data =dplyr::filter(filtered_data, has_ER), aes(y = 0.090), alpha= 0.8, color = "chocolate", size = 1) + # GPP presence tick marks
  scale_y_continuous(name = "", breaks = NULL) +
  theme_classic() + xlab(NULL) +
    labs(title = "GB Lower - ER") +facet_grid(year~.)
templt
```

```{r, warning=F, size = 'small', echo=F, include=F}
#####
date_datf_plt <- date_datf %>%
  mutate(yday=yday(date),
         year=year(date))

date_datf_plt_gb <- date_datf_plt %>%
 dplyr::filter(site=="GBL" & year <2024) %>%
  left_join(filtered_data_cs, by=c("yday", "year", "date"))

GBL_plot1 <- ggplot(date_datf_plt_gb, aes(x = yday, y = ER_cumsum, color = factor(year))) +
  geom_line(size = 1, alpha=0.95) + 
  labs(x = "Day of Water Year", color = "Year") +  xlab(NULL) +
  ylab(expression("|"~ER~"|"~(g~O[2]~m^-2~yr^-1))) +
  scale_color_manual(values=c("#440154", "#3B528B", "#4bcc94")) +
 #   scale_color_viridis_d(option = "viridis",  name = "Year") +
  theme_classic() + xlim(91, 335)
#xlim(115, 332)

GBL_plot1


date_datf_plt_sum <- date_datf_plt_gb %>%
  group_by(year) %>%
 dplyr::summarise(T_cm = max(ER_cumsum, na.rm = TRUE)) %>%
  mutate(percent_change = (T_cm[year == 2023]-T_cm) / T_cm[year == 2023] * 100)


dry_mean <- date_datf_plt_sum %>%
  dplyr::filter(year %in% c(2021, 2022)) %>%
  dplyr::summarise(dry_mean = mean(T_cm)) %>%
  pull(dry_mean)

wet_2023 <- date_datf_plt_sum %>%
  dplyr::filter(year == 2023) %>%
  pull(T_cm)

tibble(
  dry_mean = dry_mean,
  wet_2023 = wet_2023,
  diff = wet_2023 - dry_mean,
  pct_decrease = (wet_2023 - dry_mean) / dry_mean * 100
)
```




```{r, warning=F, size = 'small', echo=F, include=T,fig.width=9, fig.height=2}
# Filter the dataset to only include rows where do.obs_m or GPP_mean are not NA
plot_data_date <- covariat_datq %>%
 dplyr::filter(!is.na(do.obs_m))

plot_data_DO <- covariat_datq %>%
   dplyr::filter(site=="GBU") %>%
 dplyr::filter(!is.na(do.obs_m)) %>%
   dplyr::select(date, do.obs_m, GPP_mean) %>%
  mutate(has_do = !is.na(do.obs_m), 
         has_GPP = !is.na(GPP_mean),
         plot_GPP = ifelse(is.na(GPP_mean), 0, GPP_mean),
         yday=yday(date),
         year=year(date))

# Identify the unique yday values for each year
yday_2021 <- unique(plot_data_DO$yday[plot_data_DO$year == 2021])
yday_2022 <- unique(plot_data_DO$yday[plot_data_DO$year == 2022])
yday_2023 <- unique(plot_data_DO$yday[plot_data_DO$year == 2023])

# Find the common yday values across all three years
common_yday <- Reduce(intersect, list(yday_2021, 
                                      yday_2022, 
                                      yday_2023))

# Filter the dataframe for only those common yday values
filtered_data <- plot_data_DO %>%
 dplyr::filter(yday %in% common_yday & year %in% c(2021, 
                                             2022, 
                                             2023))

filtered_data_cs <- filtered_data %>%
  dplyr::group_by(year) %>%
  dplyr::arrange(yday, .by_group = TRUE) %>%
  dplyr::mutate(GPP_cumsum = cumsum(plot_GPP)) %>%
  dplyr::ungroup()

# Determine the date range
date_range <- range(plot_data_date$date, na.rm = TRUE)

# Create the number line plot
templt <- ggplot(filtered_data, aes(x = yday)) +
  #geom_segment(aes(x = date_range[1], xend = date_range[2], y = 0, yend = 0), linewidth = 0.2) + # Main line
  geom_point(data =dplyr::filter(filtered_data, has_do), aes(y = 0.095), alpha=0.8, color = "black", size = 1) + # DO presence tick marks
  geom_point(data =dplyr::filter(filtered_data, has_GPP), aes(y = 0.090), alpha= 0.8, color = "#579467", size = 1) + # GPP presence tick marks
  scale_y_continuous(name = "", breaks = NULL) +
  theme_classic() + xlab(NULL) +
    labs(title = "GB Upper - GPP") +facet_grid(year~.)
templt
```

```{r, warning=F, size = 'small', echo=F, include=F}
#####
date_datf_plt <- date_datf %>%
  mutate(yday=yday(date),
         year=year(date))

date_datf_plt_gb <- date_datf_plt %>%
 dplyr::filter(site=="GBU" & year <2024) %>%
  left_join(filtered_data_cs, by=c("yday", "year", "date"))

GBU_plot <- ggplot(date_datf_plt_gb, aes(x = yday, y = GPP_cumsum, color = factor(year))) +
  geom_line(size = 1, alpha=0.95) + 
  labs(x = "Day of Water Year", color = "Year", 
       title = "GB Upper") +
  ylab(expression(GPP~(g~O[2]~m^-2~yr^-1))) +
  scale_color_manual(values=c("#440154", "#3B528B", "#4bcc94")) +
 #   scale_color_viridis_d(option = "viridis",  name = "Year") +
  theme_classic() + xlim(91, 335)
# xlim(115, 340)


date_datf_plt_sum <- date_datf_plt_gb %>%
  group_by(year) %>%
 dplyr::summarise(T_cm = max(GPP_cumsum, na.rm = TRUE)) %>%
  mutate(percent_change = (T_cm -T_cm[year == 2023]) / T_cm * 100)

dry_mean <- date_datf_plt_sum %>%
  dplyr::filter(year %in% c(2021, 2022)) %>%
  dplyr::summarise(dry_mean = mean(T_cm)) %>%
  pull(dry_mean)

wet_2023 <- date_datf_plt_sum %>%
  dplyr::filter(year == 2023) %>%
  pull(T_cm)

tibble(
  dry_mean = dry_mean,
  wet_2023 = wet_2023,
  diff = wet_2023 - dry_mean,
  pct_decrease = (wet_2023 - dry_mean) / dry_mean * 100
)

```



```{r, warning=F, size = 'small', echo=F, include=T,fig.width=9, fig.height=2}
# Filter the dataset to only include rows where do.obs_m or GPP_mean are not NA
plot_data_date <- covariat_datq %>%
 dplyr::filter(!is.na(do.obs_m))

plot_data_DO <- covariat_datq %>%
   dplyr::filter(site=="GBU") %>%
 dplyr::filter(!is.na(do.obs_m)) %>%
   dplyr::select(date, do.obs_m, ER_mean) %>%
  mutate(has_do = !is.na(do.obs_m), 
         has_ER = !is.na(ER_mean),
         ER_abs = (ER_mean*-1),
         plot_ER = ifelse(is.na(ER_abs), 0, ER_abs),
         yday=yday(date),
         year=year(date))

# Identify the unique yday values for each year
yday_2021 <- unique(plot_data_DO$yday[plot_data_DO$year == 2021])
yday_2022 <- unique(plot_data_DO$yday[plot_data_DO$year == 2022])
yday_2023 <- unique(plot_data_DO$yday[plot_data_DO$year == 2023])

# Find the common yday values across all three years
common_yday <- Reduce(intersect, list(yday_2021, yday_2022, yday_2023))

# Filter the dataframe for only those common yday values
filtered_data <- plot_data_DO %>%
 dplyr::filter(yday %in% common_yday & year %in% c(2021, 2022, 2023))


filtered_data_cs <- filtered_data %>%
  dplyr::group_by(year) %>%
  dplyr::arrange(yday, .by_group = TRUE) %>%
  dplyr::mutate(ER_cumsum = cumsum(plot_ER)) %>%
  dplyr::ungroup()

# Determine the date range
date_range <- range(plot_data_date$date, na.rm = TRUE)

# Create the number line plot
templt <- ggplot(filtered_data, aes(x = yday)) +
  #geom_segment(aes(x = date_range[1], xend = date_range[2], y = 0, yend = 0), linewidth = 0.2) + # Main line
  geom_point(data =dplyr::filter(filtered_data, has_do), aes(y = 0.095), alpha=0.8, color = "black", size = 1) + # DO presence tick marks
  geom_point(data =dplyr::filter(filtered_data, has_ER), aes(y = 0.090), alpha= 0.8, color = "chocolate", size = 1) + # GPP presence tick marks
  scale_y_continuous(name = "", breaks = NULL) +
  theme_classic() + xlab(NULL) +
    labs(title = "GB Upper - ER") +facet_grid(year~.)
templt
```


```{r, warning=F, size = 'small', echo=F, include=F}
#####
date_datf_plt <- date_datf %>%
  mutate(yday=yday(date),
         year=year(date))

date_datf_plt_gb <- date_datf_plt %>%
 dplyr::filter(site=="GBU" & year <2024) %>%
  left_join(filtered_data_cs, by=c("yday", "year", "date"))

GBU_plot1 <- ggplot(date_datf_plt_gb, aes(x = yday, y = ER_cumsum, color = factor(year))) +
  geom_line(size = 1, alpha=0.95) + 
  ylim(0,600) +
  labs(x = "Day of Water Year", color = "Year") +
  ylab(expression("|"~ER~"|"~(g~O[2]~m^-2~yr^-1))) +
  scale_color_manual(values=c("#440154", "#3B528B", "#4bcc94")) +
 #   scale_color_viridis_d(option = "viridis",  name = "Year") +
  theme_classic() + xlim(91, 335)
#xlim(115, 332)


date_datf_plt_sum <- date_datf_plt_gb %>%
  group_by(year) %>%
 dplyr::summarise(T_cm = max(ER_cumsum, na.rm = TRUE)) %>%
  mutate(percent_change = (T_cm -T_cm[year == 2023]) / T_cm * 100)


dry_mean <- date_datf_plt_sum %>%
  dplyr::filter(year %in% c(2021, 2022)) %>%
  dplyr::summarise(dry_mean = mean(T_cm)) %>%
  pull(dry_mean)

wet_2023 <- date_datf_plt_sum %>%
  dplyr::filter(year == 2023) %>%
  pull(T_cm)

tibble(
  dry_mean = dry_mean,
  wet_2023 = wet_2023,
  diff = wet_2023 - dry_mean,
  pct_decrease = (dry_mean-wet_2023) / dry_mean * 100
)

```

### **Figure 4**

#### Cummulative GPP and ER 

From overlapping DOY observations in each year. 

```{r, warning=F, size = 'small', echo=F, include=T,fig.width=8, fig.height=8.5}

Csum_grid <- ggarrange(
  BWL_plot,
  BWU_plot,
  GBL_plot,
  GBU_plot,
  ncol = 1, nrow = 4,
  common.legend = TRUE, 
  align=c("v"),
  labels = c("a", "c", "e", "g"),
  label.x = 0.8,  # Move label to the right
  label.y = 1, 
  legend = "bottom")

Csum_grid_er <- ggarrange(
  BWL_plot1,
  BWU_plot1,
  GBL_plot1,
  GBU_plot1,
  ncol = 1, nrow = 4,
  common.legend = TRUE, 
  align=c("v"),
  labels = c("b", "d", "f", "h"),
  label.x = 0.8,  # Move label to the right
  label.y = 1, 
  legend = "bottom")

Csum_grid_T <- ggarrange(
  Csum_grid,
  Csum_grid_er,
  ncol = 2, nrow = 1,
  common.legend = TRUE, 
  legend = "bottom")


Csum_grid_T

```

```{r, warning=F, size = 'small', echo=F, include=FALSE}
# ggsave("/Users/kellyloria/Documents/Publications/CH1\ biogeochem\ linkages/Figs/Fig_cumsum_GPP_v2.png", plot = Csum_grid_T, width = 5.5, height = 8.25, units = "in")

```

